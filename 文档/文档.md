# 星露谷项目文档

###### **目录：**

- [项目概述](#项目概述)
  - [项目背景](#项目背景)
  - [项目简介](#项目简介)
  - [项目主要功能](#项目主要功能)
- [使用设计模式重构](#使用设计模式重构)
  - [使用创建型模式重构](#使用创建型模式重构)
  - [使用结构型模式重构](#使用结构型模式重构)
  - [使用行为模式重构](#使用行为模式重构)
  - [使用课程未涉及的设计模式重构](#使用课程未涉及的设计模式重构)
- [项目展示](#项目展示)
- [总结](#总结)
  - [使用设计模式重构的意义](#使用设计模式重构的意义)
  - [本项目的重构方法](#本项目的重构方法)
  - [总结](#总结-1)
- [参考资料](#参考资料)

---

##### 项目名称：星露谷(2024年同济大学程序设计范式课程项目)

##### 团队编号：15 组

##### 团队成员：

| 姓名  | 学号      | 联系方式        | 电子邮件                  |
| --- | ------- | ----------- | --------------------- |
| 穆映雪 | 2351758 | 13163530936 | a05100936@163.com     |
| 于伊莲 | 2352993 | 18168165803 | 2352993@tongji.edu.cn |
| 张诗蔻 | 2353240 | 18980433878 | 2987991635@qq.com     |
| 王奕昕 | 2353733 | 18966812958 | 807576942@qq.com     |
| 林青滢 | 2354356 | 15259577899 | 2354356@tongji.edu.cn |

## 项目概述

### 项目背景

近年来，随着生活节奏加快与数字压力增加，越来越多玩家倾向于选择节奏舒缓、画面治愈的 “慢游戏” 来放松身心。以《星露谷物语》为代表的农场模拟类游戏，凭借其自由度高、玩法丰富、情感细腻的特点，成为独立游戏领域的现象级作品。这类游戏不仅融合了种植、养殖、建造、社交、探索等多种元素，还通过四季更替、昼夜循环和 NPC 日常行为等机制，构建出一个富有生命力的虚拟乡村世界，让玩家在耕耘与陪伴中获得成就感与情感共鸣。

在此背景下，项目通过实现一个具备完整农场生态、角色交互与场景切换功能的 2D 模拟游戏，将玩家置身于一个充满生机与温情的像素风乡村世界，在播种与收获中感受时间的流逝，在与村民的互动中体会人情的温暖，真正实现“逃离都市，回归田园”的游戏愿景。

### 项目简介

本项目是一款基于 Cocos2d-x 3.17.2 引擎开发的 2D 农场模拟游戏，灵感来源于经典独立游戏《星露谷物语》。游戏以像素风格呈现，玩家扮演一名来到乡村生活的主角，在一片待开垦的土地上开启全新的田园生活。

游戏包含多个可探索区域，支持场景无缝切换与角色位置记忆；NPC具备基本 AI 行为，可在限定范围内移动并与玩家触发对话；同时设计了背包系统、签到界面、钓鱼小游戏等辅助功能模块，提升游戏丰富度。在视听层面，项目集成了背景音乐、环境音效、UI 动画与天气效果，营造沉浸式的乡村氛围。

本项目在忠实还原经典农场模拟玩法的基础上，融入多项创新与增强功能，打造出兼具趣味性与沉浸感的乡村生活体验。主要特色包括：

- **沉浸式农场经营系统**：完整实现作物从播种、浇水、生长到收获的全周期管理，结合昼夜更替与天气变化，营造真实农耕节奏。  
- **可交互 NPC 与剧情触发**：村民与动物具备基础 AI 行为，玩家靠近时可触发对话，未来可扩展任务与好感度系统。  
- **多功能背包与物品管理**：设计多页签背包界面，支持物品拖拽、分类查看与使用操作，提升资源管理效率。  
- **多场景无缝切换**：通过场景状态管理器，实现农场、房屋、湖泊等区域间的平滑跳转，并自动保存与恢复玩家位置。  
- **丰富休闲玩法**：集成每日签到、钓鱼小游戏、动物互动等轻量级模块，增加日常游玩的多样性与乐趣。  
- **温馨视听体验**：搭配舒缓背景音乐、动态环境粒子及流畅 UI 动效，构建治愈系像素风世界。

这些特色共同构成了一个自由、温暖且富有生命力的虚拟田园，让玩家在耕耘与探索中感受慢生活的魅力。

### 项目主要功能
1. **菜单系统**：
* 游戏入口和导航，负责游戏的启动、导航和基本设置。它提供了一个友好的用户界面，让玩家能够轻松地访问游戏的各个功能模块。菜单系统包括主菜单、设置菜单、关于菜单等多个子菜单。
2. **农场场景**：
* 主要游戏区域，场景包含了一个完整的农场环境，含有地形、建筑、农作物、动物等各种游戏对象，支持多层地图和碰撞检测。
3. **角色系统**：
* 玩家可以通过控制角色来与游戏世界交互。角色系统包括角色属性、角色动作、角色状态等多个方面。角色会随着游戏的进行而升级。
4. **动物系统**：
* 动物系统管理农场上的各种动物，每个动物都有一些基本属性。
5. **种植系统**：
* 这个系统模拟了真实的农业过程，包括种植、生长、收获等阶段。农作物会随着游戏时间的推移而生长，玩家需要照料农作物以确保其正常生长。
6. **时间系统**：
* 游戏有自己的时间系统，与现实世界的时间不同。游戏时间流逝的速度可以配置，通常比现实时间快得多。时间系统包括分钟、小时、天、季节等多个时间单位。
7. **场景系统**：
* 游戏不是在一个单一的大场景中进行的，而是由多个不同的场景组成。每个场景都有自己的地图、对象、逻辑等。场景系统负责场景之间的切换、资源加载和卸载等。
8. **音频系统**：
* 音频系统提供了播放、暂停、停止、调整音量等功能。游戏中的不同场景和事件都有相应的音频，音频系统负责在适当的时机播放这些音频。游戏中各种事件和操作产生不同的音效。



## 使用设计模式的重构

### 使用创建型模式重构

### **采用生成器模式重构角色动画系统**
#### 原有问题

**1. 创建/销毁频繁导致性能抖动**

* 工具动画（用斧头、镐子）每次调用都 `Sprite::create()` → 播放 → `removeFromParent()`。
* 作物被种植 / 收割后重新创建，导致频繁分配与释放。

> 在移动端：内存分配 + autorelease 频繁触发，会造成明显的 **帧率抖动（FPS drop）**。

**2. 状态残留问题频发**

不同对象（工具、作物）被复用时，若未正确重置：

* Texture 仍旧是上一次的。
* Action 未停止。
* 调度器（scheduleUpdate）仍在运行。
* Visible、Scale、Rotation 可能处于旧状态。

**3. 维护成本高**

创建、销毁、初始化逻辑分散在代码很多处：

* `Sprite::create()`
* `removeFromParent()`
* `stopAllActions()`
* `setVisible(false)`
* `unscheduleUpdate()`

开发者容易忘记某些步骤，导致复用出现错误。

---
#### 重构的必要性
本次重构同时覆盖动画系统存在创建方式重复、初始化复杂、属性硬编码、扩展性弱的问题，使用生成器模式可将动画构建逻辑统一封装，避免重复创建流程，仅需指定prefix（路径）、frames（帧范围）、delay（速度），且链式调用能提高代码可读性，便于扩展。

---
#### UML类图
<p align="center">
  <img src="diagram/CharacterWithTools.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

---
#### 重构步骤

1. **新增 AnimationBuilder 类**：  
```cpp
class AnimationBuilder {
public:
    std::string prefix;
    int s, e;
    float delayUnit;

    AnimationBuilder& from(const std::string& p) { prefix = p; return *this; }
    AnimationBuilder& frames(int a, int b) { s = a; e = b; return *this; }
    AnimationBuilder& delay(float d) { delayUnit = d; return *this; }

    Animation* build() {
        auto anim = Animation::create();
        for (int i = s; i <= e; i++) {
            anim->addSpriteFrameWithFile(prefix + std::to_string(i) + ".png");
        }
        anim->setDelayPerUnit(delayUnit);
        anim->setLoops(-1);
        return anim;
    }
};
```
2. **角色类中使用 Builder 构建动画**
* 所有方向动画创建逻辑统一化、链式调用清晰。
```cpp
walkLeftAnimation = AnimationBuilder()
                        .from("character/Danaleft")
                        .frames(1, 3)
                        .delay(0.1f)
                        .build();
walkLeftAnimate = Animate::create(walkLeftAnimation);
walkLeftAnimate->retain();
```  

#### 改进与收益
使用生成器模式重构动画创建部分，使动画系统变得统一、可维护、可扩展：  

| 问题           | 改进后                      |
| ---------------- | ---------------------- |
| 多处写重复动画创建代码  | 动画逻辑封装在 Builder 中        |
| 动画创建耦合在角色逻辑中 | 动画构建独立成类，职责清晰            |
| 维护困难         | 任何动画资源修改只需改 Builder 调用即可 |
| 扩展麻烦         | 添加新动画只需一行 Builder 调用     |  

有效解决重复代码、扩展性差、灵活性不足的问题；动画创建逻辑与角色逻辑解耦，维护和扩展成本显著降低。

---

### **采用工厂模式重构动物与作物系统**
#### **原有问题**
**1. 接口不一致，初始化方式分散**

动物（`Sheep`、`Cow`、`Parrot` 等）与作物（`Wheat`、`Corn`、`Tomato` 等）都存在类似问题：

```cpp
static Sheep* create(const std::string& filename);
bool Sheep::init(const std::string& filename);

static Crop* create(const std::string& filename);
bool Crop::init(const std::string& filename);
```
问题：

* 每个子类都必须自己实现 `create()` 和 `init()`
* 初始化流程分散在不同类中
* 代码重复率极高，不同子类的初始化逻辑不一致

**2. 扩展性弱：新增一个类型要修改多处代码**

新增 `Sheep`、`Tomato` 时必须：

* 添加类
* 写新的 `init`
* 写新的 `create`
* 业务逻辑中手动调用 `Sheep::create()` 或 `Wheat::create()`

违反 **开闭原则 OCP**


**3. 高耦合：外部逻辑依赖具体子类名**

```cpp
auto a = Sheep::create("sheep.png");
auto crop = Wheat::create("wheat.png");
```

导致：

* 业务代码依赖所有子类
* 无法根据字符串、配置文件、随机机制动态创建
* 阻碍数据驱动（JSON/CSV 配置）方式

**4. 构造逻辑分散难以统一管理**

作物系统：

* `pregrowthTime`
* `growthTime`
* `matureTime`
* 生命周期状态机（`seed` → `growing` → `matured` → `dead`）

动物系统：

* 不同的动画节点
* 不同行为属性

这些初始值散落在每个类里，不利于统一配置与调优。

---
#### **重构必要性**
如果不进行重构，系统将长期面临一系列严重问题：`create`/`init` 逻辑需要在几十个地方重复编写，导致代码冗余且难以维护；每当新增一种动物或作物类型时，必须同时修改多处代码，造成高度耦合，极大增加了出错风险；由于初始化方式不统一，极易引发难以追踪的 Bug，显著拉长调试周期；更关键的是，当前架构无法支持数据驱动的设计，使得动物和作物系统的扩展必须依赖硬编码，大幅抬高了后续功能迭代的成本；同时，分散的创建逻辑也让性能优化变得支离破碎，无法集中实施有效的策略。因此，必须引入工厂方法模式，通过将对象的创建过程封装到专门的工厂中，实现创建逻辑的统一管理、解耦类型依赖。

---

#### **重构步骤**

1. **统一动物创建工厂**

```cpp
class AnimalFactory {
public:
    static Animal* createAnimal(const std::string& filename);
};
```

```cpp
Animal* AnimalFactory::createAnimal(const std::string& filename) {
    std::string lower = filename;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);

    if (lower.find("sheep") != std::string::npos)
        return Sheep::create(filename);

    if (lower.find("cow") != std::string::npos)
        return Cow::create(filename);

    if (lower.find("parrot") != std::string::npos)
        return Parrot::create(filename);

    CCLOG("Unknown animal type: %s", filename.c_str());
    return nullptr;
}
```
2. **统一作物创建工厂**

```cpp
class CropFactory {
public:
    static Crop* createCrop(const std::string& type);
};
```

```cpp
Crop* CropFactory::createCrop(const std::string& type) {
    auto crop = Crop::create();
    if (!crop) return nullptr;

    if (type == "wheat") {
        crop->setInitialTexture("plant/wheat_seed.png");
        crop->setMatureTime(3.0);
    } else if (type == "corn") {
        crop->setInitialTexture("plant/corn_seed.png");
        crop->setMatureTime(4.0);
    } else if (type == "pumpkin") {
        crop->setInitialTexture("plant/pumpkin_seed.png");
        crop->setMatureTime(5.0);
    } else {
        crop->setInitialTexture("plant/cropseed.png");
        crop->setMatureTime(3.0);
    }

    return crop;
}
```
---

#### **改进与收益**

* 动物和作物创建不再依赖具体类，所有作物/动物通过工厂创建，用统一的接口，外部无需知道子类。

**2. 完全解耦**

```cpp
#include "AnimalFactory.h"
#include "CropFactory.h"
```

业务层不用再 include：

* Sheep
* Cow
* Wheat
* Corn

耦合度大幅降低。

**3. 强扩展性**

添加新类型：

```cpp
class Horse : public Animal { ... };
```

只需在工厂内部添加判断：

```cpp
if (type == "horse") return Horse::create();
```

外部代码 **零改动**。

---

### **4. 支持脚本/配置驱动**

可直接从 JSON、Lua、CSV 动态创建对象：

```cpp
auto crop = CropFactory::createCrop(config["cropType"].asString());
```


### 使用结构型模式重构
#### 采用外观模式重构场景管理器


#### 采用适配器模式重构场景管理器
#### 原有问题
1. **接口不一致**：
   ```cpp
   // 不同场景的创建方法接口不统一
   valleybegin::createvalleybeginScene()        // 无参数
   menu::createmenuScene()                      // 无参数
   outside::createSceneWithMapIndex(int)        // 需要参数
   intovalley::createintovalleyScene()          // 无参数
   othersence::createothersenceScene()          // 无参数
   ```

2. **高耦合**：
   ```cpp
   // GameSceneFacade.h 直接依赖所有场景类
   #include "valleybegin.h"
   #include "menu.h"
   #include "outside.h"
   #include "intovalley.h"
   #include "othersence.h"
   ```

3. **难以扩展**：
   - 添加新场景需要修改 `GameSceneFacade`
   - 场景创建逻辑分散，难以统一管理
   - 无法添加统一的场景创建前处理（如资源预加载、参数验证等）
#### 重构方案
##### 设计结构：
```
ISceneCreator (统一接口)
    ↑
    ├── ValleyBeginSceneAdapter
    ├── MenuSceneAdapter
    ├── FarmSceneAdapter (适配带参数的场景)
    ├── HouseSceneAdapter
    └── OtherAreaSceneAdapter

SceneAdapterManager (管理所有适配器)
    ↓
GameSceneFacade (通过适配器创建场景，不再直接依赖具体场景类)
```
##### 实际应用：
1. **创建农场场景**
```cpp
// 使用适配器，统一接口
ValueMap params;
params["mapIndex"] = Value(2);
Scene* farmScene = SceneAdapterManager::getInstance()->createScene("Farm", params);
```

2. **添加新场景（无需修改 Facade）**
```cpp
// 1. 创建新场景适配器
class ShopSceneAdapter : public ISceneCreator {
public:
    Scene* createScene(const ValueMap& params) override {
        // 适配新的场景创建方法
        return ShopScene::createShopScene();
    }
    std::string getSceneType() const override { return "Shop"; }
};

// 2. 注册适配器（在 SceneAdapterManager 构造函数中）
registerAdapter("Shop", new ShopSceneAdapter());

// 3. 在 Facade 中添加方法（可选，也可以直接调用适配器）
void GameSceneFacade::enterShopScene() {
    Scene* scene = getAdapterManager()->createScene("Shop");
    Director::getInstance()->pushScene(scene);
}
```

3. **场景预加载**
```cpp
// 在进入场景前预加载资源
void GameSceneFacade::enterFarmScene(int mapIndex) {
    // 预加载农场场景资源
    getAdapterManager()->preloadSceneResources("Farm");
    
    // 创建场景
    ValueMap params;
    params["mapIndex"] = Value(mapIndex);
    Scene* scene = getAdapterManager()->createScene("Farm", params);
    // ...
}
```

#### 核心优势
1. **统一接口**
```cpp
// 所有场景都通过统一接口创建
Scene* scene = adapterManager->createScene("Farm", params);
```
2. **解耦合**
```cpp
// GameSceneFacade.h 不再需要包含具体场景类
// 只需要包含 SceneAdapter.h
#include "SceneAdapter.h"  // 只依赖适配器接口
```
3. **易于扩展**
```cpp
// 添加新场景只需：
// 1. 创建新的适配器类
class NewSceneAdapter : public ISceneCreator { ... };

// 2. 注册到管理器
adapterManager->registerAdapter("NewScene", new NewSceneAdapter());

// 3. 在 Facade 中使用
adapterManager->createScene("NewScene");
// 无需修改 GameSceneFacade 的现有代码！
```

4. **参数统一处理**
```cpp
// 使用 ValueMap 统一传递参数，适配器内部处理参数转换
ValueMap params;
params["mapIndex"] = Value(1);
Scene* scene = adapterManager->createScene("Farm", params);
```

#### 设计模式组合总结
这个方案巧妙地结合了两种结构型模式：
1. **外观模式 (Facade)**：
   - `GameSceneFacade` 提供统一的场景切换接口
   - 隐藏 `Director` 和场景创建的复杂性
2. **适配器模式 (Adapter)**：
   - `SceneAdapter` 统一不同场景的创建接口
   - 解耦 `GameSceneFacade` 与具体场景类
**两种模式相互配合，实现了更好的解耦和扩展性！**


### 使用行为模式重构

#### 使用策略模式 + 状态模式进行重构

#### 原有问题

1. **代码重复问题**：
* **DRY 原则违反**：相同的动画创建逻辑重复 3 次 。

* **维护困难**：动画参数分散在多个地方，修改一处需要改三处，容易遗漏且引入不一致性，最后需要大量的测试验证。

```cpp
bool Sheep::init(const std::string& filename){
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Sheep" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}

bool Cow::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Cow" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}

bool Parrot::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Parrot" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}


```

2. **缺乏行为抽象**：系统中不同对象的行为没有被抽象成接口或基类，而是硬编码在具体的类中
- **行为固定，无法扩展**：所有动物都使用相同的移动逻辑，无法为不同对象定制不同的行为，无法实现不同的移动方式。
- **难以测试**：行为与数据紧耦合，行为直接访问和修改数据成员，无法独立测试行为和数据，也无法重用行为。


```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta * speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

3. **状态管理混乱**：
- **状态隐式**：原始代码中没有显式的状态管理，动物的行为完全由 update() 方法决定
- **行为难以理解**：没有获取状态的方法，无法清晰地了解当前对象所处的状态。状态与数据混淆在一起，无法清晰地区分。
- **无法转换**：原始代码中，动物只能处于一种隐式的状态：移动到目标。无法灵活地在不同状态间切换。

```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta * speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

4. **紧耦合设计**：
<p align="center">
  <img src="diagram/Coupled p.svg" alt="Presentation Layer" style="width:70%; max-width:700px; height:auto;"/>
</p>

* 羊，牛，鹦鹉子类的`init()`函数与`Sprite` , `Animation` ,` Animate`类耦合，一个模块的改变会直接影响其他模块，产生修改涟漪效应，导致代码难以维护和扩展。在测试方面，无法单独隔离测试子类，且测试速度慢，测试不稳定。

5. **难以添加新的功能**：
* 所有动物行为都在单一的 `update()` 方法中，包括的职责有：计算方向，更新位置，检查距离，生成新目标。这是一个"上帝方法"，做的事情太多，让阅读者难以理解。添加新的功能后，代码会迅速膨胀，且条件判断复杂，违反“开闭原则”。

```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta *speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

6. **动画单一，视觉效果不佳**：
* 每个动物类型只有一种固定动画，暂时只有“默认行走”动画。无法体现不同行为的视觉差异，玩家将无法通过角色动作直观感知其行为意图——休息时仍在走动、追逐时速度无变化且动作无紧张感，严重削弱沉浸感与反馈清晰度，导致角色行为“表里不一”，降低游戏表现力与可信度。

#### 重构的必要性
* **业务需求驱动**：当前只有3 种动物（羊、牛、鹦鹉）， 1 种行为（游荡），1 种动画；而未来需要扩展更多种动物、行为种类（游荡、休息、追踪、觅食、逃跑）以及多种的动态动画切换。原始代码无法满足这些需求，重构后可以轻松扩展。
* **技术债务**：当代码重复率高达30-40%，代码中的决策点多，路径复杂，模块间耦合度高，容易有出错概率高，测试和维护难度越大。重构后可以降低维护成本，提高开发效率
* **开发效率**：原始代码添加新动物需要写 50+ 行重复代码，修改动画参数需要改 3 个地方，添加新行为需要修改 `update()` 方法，使得方法冗长。重构后添加新动物：只需写 10 行代码，修改动画参数只需改 1 个地方，添加新行为只需创建新状态类。效率提升效果明显。
* **游戏视觉**：原始代码的动物行为简单直接，适合开发初始阶段，可能美术资源未就位。重构后，在策略模式和行为模式的基础上，将动画与行为解耦，做到动物的动画展示随状态改变而改变，增强游戏的体验感和视觉享受。

#### UML类图
* 策略模式类图
<p align="center">
  <img src="diagram/Strategy.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

<br></br>

* 状态模式类图
<p align="center">
  <img src="diagram/State.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>


#### 重构步骤
为解决上述问题，将运用策略模式和状态模式，将"所有动物共享一套固定的初始化和移动逻辑"重构为"每个动物可以选择自己的动画策略和运动状态"。让代码更好地服务于业务，以便之后更高效地开发和维护。

1. **明确重构目标**：
* **遵循单一职责原则**：`Animal` 只负责持有状态/策略，重构其他类专注行为逻辑和视觉表现。
* **遵循开闭原则**：使得新增动物类型，新增移动行为，更换动画风格更加容易。
* **解耦具体实现，依赖抽象**：底层图形引擎变化时，`Animal` 几乎不用改。
* **行为与动画解耦**：每个动物支持三种行为状态，同一动物可拥有多个策略，按需切换。
2. **建立动画策略体系**：
* 新建 `AnimationStrategy.h`
* 定义抽象接口 `AnimationStrategy`
```cpp
class AnimationStrategy {
public:
    virtual ~AnimationStrategy() = default;
    virtual void applyAnimation(Sprite* sprite) = 0;
};
```
* 实现通用策略类 `GenericAnimationStrategy`，支持按前缀加载帧序列
```cpp
class GenericAnimationStrategy : public AnimationStrategy {
private:
    std::string prefix;   
    int frameCount;
    float delay;

public:
    GenericAnimationStrategy(const std::string& animPrefix, int count = 4, float d = 0.1f)
        : prefix(animPrefix), frameCount(count), delay(d) {}

    void applyAnimation(Sprite* sprite) override {
        auto animation = Animation::create();
        bool hasValidFrame = false;
        for (int i = 1; i <= frameCount; ++i) {
            std::string frameName = prefix + std::to_string(i) + ".png";
            auto frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(frameName);
            if (!frame) {
                auto texture = Director::getInstance()->getTextureCache()->addImage(frameName);
                if (texture) {
                    Rect rect = Rect::ZERO;
                    rect.size = texture->getContentSizeInPixels();
                    frame = SpriteFrame::createWithTexture(texture, rect);
                    hasValidFrame = true;
                }
            } else {
                hasValidFrame = true;
            }
            if (frame) {
                animation->addSpriteFrame(frame);
            }
        }

        if (!hasValidFrame) {
            CCLOG("Warning: No valid frames for animation prefix: %s", prefix.c_str());
            return;
        }

        animation->setDelayPerUnit(delay);
        animation->setLoops(-1); // loop forever
        auto animate = Animate::create(animation);
        sprite->stopAllActions();
        sprite->runAction(animate);
    }
};
```

3. **定义行为状态机**：
* 新建 `AnimalState.h`
* 声明抽象基类 `AnimalState`
```cpp
class AnimalState {
public:
    virtual ~AnimalState() = default;
    virtual void enter(Animal* animal) = 0;
    virtual void update(Animal* animal, float delta) = 0;
    virtual void exit(Animal* animal) = 0;
    virtual std::string getName() const = 0;
};
```
* 实现三种具体状态：
    * `WanderingState`：随机移动 + wander 动画
    * `ChasingState`：朝目标移动 + chase 动画（可设追逐点）
    * `RestingState`：静止 + rest 动画，3 秒后自动切回 wandering
```cpp
// ------------------ Wandering ------------------
class WanderingState : public AnimalState {
public:
    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            std::make_unique<GenericAnimationStrategy>(animal->getAnimPrefix() + "_wander")
        );
        animal->generateNewTarget();
    }

    void update(Animal* animal, float delta) override {
        Vec2 dir = animal->getTargetPosition() - animal->getPosition();
        if (dir.length() < 10.0f) {
            animal->generateNewTarget();
        } else {
            animal->setPosition(animal->getPosition() + dir.getNormalized() * animal->getSpeed() * delta);
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Wandering"; }
};

// ------------------ Chasing ------------------
class ChasingState : public AnimalState {
private:
    Vec2 chaseTarget;
public:
    void setChaseTarget(const Vec2& target) { chaseTarget = target; }

    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            std::make_unique<GenericAnimationStrategy>(animal->getAnimPrefix() + "_chase")
        );
    }

    void update(Animal* animal, float delta) override {
        Vec2 dir = chaseTarget - animal->getPosition();
        if (dir.length() > 5.0f) {
            animal->setPosition(animal->getPosition() + dir.getNormalized() * animal->getSpeed() * 1.8f * delta);
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Chasing"; }
};

// ------------------ Resting ------------------
class RestingState : public AnimalState {
private:
    float restTime = 0.0f;
    const float MAX_REST = 3.0f;

public:
    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            std::make_unique<GenericAnimationStrategy>y(animal->getAnimPrefix() + "_rest")
        );
        restTime = 0.0f;
    }

    void update(Animal* animal, float delta) override {
        restTime += delta;
        if (restTime >= MAX_REST) {
            animal->changeState(std::make_unique<WanderingState>());
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Resting"; }
};

```

4. **改造 Animal 基类**：
* 在 `Animal.h` 中：
    * 添加成员：`unique_ptr<AnimalState> currentState` 和 `unique_ptr<AnimationStrategy> currentAnimation`
    * 添加方法：`changeState()`、`setAnimationStrategy()`
    * 声明虚函数 `getAnimPrefix()` 供子类指定资源前缀

```cpp
class Animal : public Sprite {
protected:
    Vec2 targetPosition; 
    Rect Bounds;
    float speed;
    std::string animPrefix;

    std::unique_ptr<AnimalState> currentState;
    std::unique_ptr<AnimationStrategy> currentAnimation;

public:
    Animal();
    virtual ~Animal();
    static Animal* create(const std::string& filename);
    virtual bool init(const std::string& filename) = 0;

    void generateNewTarget();
    void update(float delta);

    // State & Animation Control
    void changeState(std::unique_ptr<AnimalState> newState);
    void setAnimationStrategy(AnimationStrategy* strategy);

    // Getters
    Vec2 getTargetPosition() const { return targetPosition; }
    void setTargetPosition(const Vec2& pos) { targetPosition = pos; }
    float getSpeed() const { return speed; }
    const std::string& getAnimPrefix() const { return animPrefix; }
    const Rect& getBounds() const { return Bounds; }
};
```
* 在 Animal.cpp 中：
    * 实现 `update()` 转发给当前状态
    * 实现状态切换逻辑（调用 exit → enter）
    * 在 `setAnimationStrategy()` 中应用新动画并停止旧动作
```cpp
void Animal::update(float delta) {
    if (currentState) {
        currentState->update(this, delta);
    }
}

void Animal::changeState(std::unique_ptr<AnimalState> newState) {
    if (currentState) {
        currentState->exit(this);
    }
    currentState = std::move(newState);
    if (currentState) {
        currentState->enter(this);
    }
}

void Animal::setAnimationStrategy(AnimationStrategy* strategy) {
    currentAnimation.reset(strategy);
    if (strategy && this->isRunning()) {
        strategy->applyAnimation(this);
    }
}
```

5. **更新具体动物类**
* 修改 `Sheep`、`Cow`、`Parrot` 的构造函数：
    * 设置各自的 `animPrefix`
    * 初始化时调用 `changeState(std::make_unique<WanderingState>())`
* 移除原有硬编码动画逻辑

```cpp
bool Sheep::init(const std::string& filename){
   if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Sheep image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Sheep";
    changeState(std::make_unique<WanderingState>());
    return true;
}

```
```cpp
bool Cow::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Cow image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Cow";
    changeState(std::make_unique<WanderingState>());
    return true;
}
```

```cpp
bool Parrot::init(const std::string& filename) {
     if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Parrot image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Parrot";
    changeState(std::make_unique<WanderingState>());
    return true;
}
```

#### 改进与收益
1. **降低代码重复率**：
* 原来每个子类都要自己创建动画，但创建逻辑完全相同。子类继承了基类的所有代码，但无法复用基类的逻辑，只能重复实现。用抽象层进行集中管理后，可以避免在许多地方重复编写相同的代码
2. **降低耦合度**：
* 重构后 `Animal` 耦合 `AnimationStrategy` 和 `AnimalState` ，与 `Sprite` 、`Animation` 、`Animate` 松耦合。Animal 只负责“动物”的高层逻辑，动画和移动细节交给策略/状态，符合单一职责原则。
3. **增强扩展性**：
* 添加新的动物行为状态，只需要在 `AnimalState.h` 中新增状态类。代码可以在运行时改变动画策略和状态。
4. **提高代码的可读性**：
* 将策略和状态独立成类，使得代码结构更加清晰，意图明确，需要注释的地方减少。
5. **“状态”真正驱动“表现”**:
* 动画策略与“状态”对齐，而非与“动物类型”绑定。每个动物支持三种行为状态，同一动物可拥有多个策略，按需切换。状态切换时自动切换对应动画，动画资源与行为状态一一对应，清晰明确使用带参数的通用策略，而非为每种组合创建新类，可以防止类的爆炸

### 使用观察者模式重构

#### 原有问题

在当前的整个游戏事件系统中，事件（作物生长、成熟、收获、时间变化等）全部由相关类自行处理，没有统一的事件调度机制，表现逻辑与业务逻辑强耦合。

**代码片段 1：Plantingcrops.cpp – 作物成熟逻辑与 UI 逻辑耦合**

```cpp
if (state == State::growing) {
    growthTime += delta;
    if (growthTime >= matureTime) {
        state = State::matured;
        this->setTexture("plant/matured.png");   // 直接修改贴图
        log("Crop matured!");                    // 输出日志
    }
}
```

**问题分析**

1. **紧耦合**：作物成熟发生后，直接在此类内部执行贴图更新与 UI 表达，可视化层与业务层混杂，无法复用与扩展。
2. **缺乏事件对外通知机制**：成熟事件只在自身内部被处理，任务系统、统计系统、音效模块无法获知该事件，新需求必须直接修改此类，违反开放封闭原则（OCP）。


**代码片段 2：Plantingcrops.cpp – 自动收获逻辑**

```cpp
else if (state == State::matured) {
    growthTime += delta;
    if (growthTime >= matureTime * 3) {
        state = State::harvested;
        this->setTexture("plant/cropharvested.png");
    }
}
```

**问题分析**

1. **自动收获后没有向系统发出任何信号**：UI 不会显示消失提示，音效不触发，任务计数不会更新。
2. **不同事件语义（手动/自动收获）无法区分**：系统无法区分手动收获和自动收获或凋零的事件类型。


**代码片段 3：outside.cpp – 时间推移与 UI 强耦合**

```cpp
void outside::updateTime(float dt) {
    totalTime += dt;
    if (totalTime >= 60) {
        minute++;
        totalTime = 0;
        auto label = dynamic_cast<Label*>(getChildByName("timeLabel"));
        label->setString(StringUtils::format("%d", minute));  // 直接操作UI
    }
}
```

**问题分析**

1.**outside 既负责时间系统，又负责 UI 展示，承担多重职责**：违反了单一职责原则。
2.**UI 必须依附于 outside**：若未来加入 InDoorScene 或 TownScene 必须复制同样逻辑，代码重复严重。


#### 总结原有问题

结合上述代码分析，valley-main 当前事件系统存在以下结构性问题：

1. **事件分散在多个业务类内部，没有统一事件中心**：Crop、outside、UI 控件各自处理逻辑，缺乏统一协调。
2. **事件没有向外通知的机制，无法实现模块间协作**：成熟、死亡、收获、时间变化事件无法广播给 UI、音效、任务系统。
3. **表现层与业务层紧耦合，职责混乱**：状态变化和视觉表现写在一起，难以维护。
4. **系统扩展性差，新增功能必须修改多个源文件**：不支持多观察者接入（UI、音效、成就系统等）。


#### 重构必要性

当前 valley-main 的事件系统紧耦合、难扩展、事件传播链不完整。因此有必要引入**观察者模式（Observer Pattern）**，将事件发布与事件处理解耦，实现统一事件流转。
观察者模式通过 EventCenter 统一管理事件订阅与分发，实现：
- 事件从触发源传播到多个观察者
- 事件逻辑与表现逻辑分离
- 支持模块动态扩展，不需要修改现有代码
从而显著提高系统扩展性与维护性。

#### UML类图

* 观察者模式类图
<p align="center">
  <img src="source/ObserverPatternUML.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

#### 重构步骤

为了使用观察者模式重构 valley-main 的事件系统，我们将事件处理逻辑从作物、场景等类中解耦出来，使它们只负责状态变更和事件发布，而事件处理由观察者统一承担。具体步骤如下：

**1. 定义观察者接口**

创建一个 Observer 接口，定义所有观察者需要实现的方法（如 onNotify）。

```cpp
class Observer {
public:
    virtual ~Observer() = default;
    virtual void onNotify(const EventData& event) = 0;
};
```


**2. 定义事件类型与事件数据结构**

实现事件系统所需的枚举类型与事件封装对象。

```cpp
enum class EventType {
    MinuteChanged,
    CropMatured,
    CropHarvested,
    CropDead
};

class EventData {
public:
    EventType type;
    void* sender;

    EventData(EventType t, void* s) : type(t), sender(s) {}
};
```


**3. 创建统一事件中心（Subject）**

将事件中心设计成被观察者（Subject），负责维护观察者列表，并在事件发布时通知观察者。EventCenter 被设计为 全局单例（Global Singleton），确保系统中所有事件源与观察者始终共享同一个事件中心。
单例模式使事件管理具备唯一性与一致性，避免多个事件中心造成的事件分裂、消息丢失、同步混乱等问题，

```cpp
class EventCenter {
public:
    static EventCenter* getInstance();

    void attach(Observer* obs) { observers.pushBack(obs); }
    void detach(Observer* obs) { observers.eraseObject(obs); }

    void publish(EventType type, void* sender) {
        EventData event(type, sender);
        for (auto obs : observers) {
            obs->onNotify(event);
        }
    }

private:
    cocos2d::Vector<Observer*> observers;
};
```


**4. 修改 Crop 类：将作物状态变化改为事件发布**

将原本直接修改 UI 或场景状态的逻辑移除，改成发布事件。

示例（来自 Plantingcrops.cpp）：

```cpp
if (state == State::matured) {
    // ★ 新增：发布成熟事件
    EventCenter::getInstance()->publish(EventType::CropMatured, this);
}
```

```cpp
void Crop::harvest() {
    state = State::harvested;

    // ★ 新增：发布手动收获事件
    EventCenter::getInstance()->publish(EventType::CropHarvested, this);
}
```


**5. 修改 outside 类：使其继承 Observer，实现 onNotify**

```cpp
class outside : public cocos2d::Layer, public Observer {
public:
    virtual void onNotify(const EventData& event) override;
};
```

在 outside.cpp 中添加事件处理逻辑（例如处理时间变化事件）：

```cpp
void outside::onNotify(const EventData& event) {
    if (event.type == EventType::MinuteChanged) {
        auto label = dynamic_cast<Label*>(getChildByName("timeLabel"));
        if (label) {
            label->setString(this->getFormattedTime());
        }
    }
}
```


**6. 将原本分散在各类中的 UI 更新逻辑迁移到 onNotify**

移除 outside::updateTime() 中的 UI 直接更新代码。

**原逻辑：**
```cpp
label->setString(...);
```

**重构后：**
- updateTime() 只发布事件
- 所有 Label 更新统一在 onNotify 中执行

```cpp
EventCenter::getInstance()->publish(EventType::MinuteChanged, this);
```

---

**7. 在 outside::init() 中进行观察者注册**

```cpp
bool outside::init() {
    EventCenter::getInstance()->attach(this);
    ...
    return true;
}
```

至此，outside 成为全局事件系统的观察者，能够响应 Crop 和场景事件。

#### 改进与收益

1. **解耦与抽象**：通过定义 Observer 接口，将事件处理逻辑从作物类、场景类中彻底分离，使原本杂糅在内部的 UI 更新、任务处理等逻辑独立出来，形成清晰的观察者架构。
2. **单一职责原则**：Crop 不再负责 UI 显示与其他模块逻辑，只负责自身的生命周期与事件发布；outside 只负责渲染与事件响应。每个模块职责更加明确。
3. **提高扩展性**：将来新增观察者时不需要修改 Crop、outside 等事件源代码，系统具备良好的可扩展性。
4. **动态事件响应机制**：EventCenter 支持运行时 attach/detach 观察者，使得系统可以灵活控制哪些功能启用或关闭。
5. **提升代码复用性**：统一事件入口（onNotify）与事件中心共享机制让 UI 更新、音效、任务统计等跨模块逻辑不再重复，相关处理集中在各自观察者类中。
6. **降低耦合度，系统结构更清晰**：事件源（Crop等）不再直接操作 UI，不再依赖外部模块代码，消除了"谁调用谁"的混乱引用，整体代码层次更加直观。
7. **未来支持更多事件类型**：无论新增节日触发、天气变化、NPC 行为等事件，只需定义新的 EventType 并在事件源发布，现有系统即可自动兼容。

#### 对 AI工具的使用情况：事件系统设计思路的探索与选择

###### 遇到的问题：
项目初期，事件传播逻辑高度分散，各模块之间存在大量直接调用（如 Crop 直接操作 UI，outside 同时负责时间逻辑与 UI）。导致代码紧耦合、难以维护和扩展。随着需求增加（天气、节日、外部 UI 页），现有架构已无法承载。

###### 向AI提问
我向 AI 描述了这个问题，并提问：
How can I build an event notification system between game modules to reduce coupling?
（如何实现游戏模块间的事件通知以降低耦合度？）

###### AI 的贡献与我的决策
AI 向我介绍了观察者模式（Observer Pattern）的完整结构框架，并指出可使用全局事件中心统一事件调度。经过理解与对比后，我认为此模式非常适合 valley-main 的需求，因此采用 Observer Pattern 重构事件流转逻辑，建立 EventCenter → Observer → ConcreteObserver 结构。

#### 其他重要问题及其对应解决方案
##### 解决了什么问题： 
valley-main 的事件源（Crop、outside）与 UI 展示代码直接耦合，状态变化与视觉表现混杂在一起，导致业务逻辑与渲染逻辑高度绑定，代码结构混乱且难以维护。新增需求（如音效、任务系统、统计系统）必须修改原有类，实现方式不可扩展。
##### 带来了什么收益
通过引入 EventCenter 作为统一事件调度中心，采用 Observer Pattern，将表现逻辑从事件源分离，转移至 onNotify() 回调中。事件源只负责状态变更和发布事件，不再关心具体响应行为。UI、音效、统计等模块通过订阅方式解耦联动，使系统结构清晰、层次分明，新增功能只需扩展观察者类即可，无需修改原代码，显著提升扩展性、可维护性和代码质量。

## 使用课程未涉及的设计模式重构

### 使用对象池模式重构

#### 模式解释  
**对象池模式**是一种创建型设计模式，它通过**预先创建并复用一组初始化好的对象**，避免在运行时频繁地创建和销毁对象。当客户端需要对象时，从池中“借出”；使用完毕后，将对象“归还”到池中，而不是直接销毁。该模式特别适用于**创建成本高、使用频繁、生命周期短**的对象管理。

#### 核心思想  
- **复用优于重建**：对象不是用完就丢，而是回收再利用。  
- **资源预分配**：在系统空闲或启动时预先创建一批对象，减少运行时开销。  
- **控制资源总量**：通过池大小限制并发对象数量，防止内存爆炸。

#### 工作流程  
1. **初始化池**：创建一批对象，放入“空闲队列”。
2. **获取对象**：
   - 若空闲队列非空 → 取出一个对象，重置其状态（如位置、属性），返回给客户端。
   - 若队列为空 → 可选择：
     - 阻塞等待；
     - 动态创建新对象（可选）；
     - 抛出异常（严格池）。
3. **归还对象**：客户端调用 `release()`，对象被放回空闲队列（不清除内存）。
4. **销毁池**：程序结束时统一释放所有对象。

#### 优点  
* **提升性能** ：避免频繁 `new/delete` 或 `malloc/free` 的开销（尤其对复杂对象）。
* **减少内存碎片** ：对象地址相对固定，降低堆内存碎片化。 
* **控制资源使用** ：限制最大对象数，防止系统过载（如数据库连接池）。 
* **降低 GC 压力**：减少临时对象生成，减轻垃圾回收负担 。
* **提高响应速度**： 获取对象是 O(1) 操作，无初始化延迟 。

#### 缺点  
* **内存占用增加**：对象常驻内存，即使未使用也占用空间。
* **状态管理复杂**：归还对象必须彻底重置状态，否则会污染下一次使用。
* **线程安全问题**：多线程环境下需加锁，可能成为性能瓶颈。
* **不适合长生命周期对象**：若对象长期被占用，池的优势无法体现。
* **调试困难**：对象复用可能导致难以追踪的逻辑错误（如残留数据）。

#### 应用场景  
* **游戏开发**：子弹、粒子、敌人、动画对象（频繁创建/销毁）。
* **Web 后端**：数据库连接池（如 HikariCP）、HTTP 客户端池。
* **网络编程**：Socket 连接、缓冲区（Buffer）复用。
* **科学计算**：矩阵、向量等大型数据结构缓存。
* **移动端**：RecyclerView / ListView 的 ViewHolder 复用（Android）。
* **AI/仿真系统**：传感器数据包、事件对象池。

---

#### 原有问题
1. **资源耗尽风险**
- 每次请求或任务都创建新线程，线程数量可能无限制增长。
- 大量线程会耗尽内存，导致 `OutOfMemoryError`。

2. **性能开销大**
- 线程创建/销毁成本高，涉及内核调度、内存分配、上下文切换等。
- 频繁创建线程会导致 CPU 大量时间花在调度而非业务逻辑上。
- 响应延迟增加，吞吐量下降。

3. **缺乏控制与管理**
- 无法限制最大并发数，容易引发雪崩效应。
- 无法监控活跃线程数、任务队列状态。
- 无法优雅关闭、等待任务完成、拒绝过载任务等。

4. **缺乏高级功能支持**
- 无法实现定时任务、周期任务（需配合 `Timer` 或手动实现）。
- 不支持任务返回结果（`Future`）、超时控制、批量提交等。

#### 重构的必要性

#### UML类图
* 对象池类图
<p align="center">
  <img src="source/.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>



#### 重构步骤



#### 改进与收益

