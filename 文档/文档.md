# 星露谷项目文档

###### **目录：**

- [项目概述](#项目概述)
  - [项目背景](#项目背景)
  - [项目简介](#项目简介)
  - [项目主要功能](#项目主要功能)
- [使用设计模式重构](#使用设计模式重构)
  - [使用创建型模式重构](#使用创建型模式重构)
  - [使用结构型模式重构](#使用结构型模式重构)
  - [使用行为模式重构](#使用行为模式重构)
  - [使用课程未涉及的设计模式重构](#使用课程未涉及的设计模式重构)
- [AI工具使用情况的阐述](#AI工具使用情况的阐述)
    - [模式设计的探索和选择](#模式设计的探索和选择)
    - [具体代码的重构与生成](#具体代码的重构与生成)
    - [反思与讨论](#反思与讨论)

- [重构的价值主张：设计模式视角](#重构的价值主张：设计模式视角)
- [总结](#总结)


---

##### 项目名称：星露谷(2024年同济大学程序设计范式课程项目)

##### 团队编号：15 组

##### 团队成员：

| 姓名  | 学号      | 联系方式        | 电子邮件                  |
| --- | ------- | ----------- | --------------------- |
| 穆映雪 | 2351758 | 13163530936 | a05100936@163.com     |
| 于伊莲 | 2352993 | 18168165803 | 2352993@tongji.edu.cn |
| 张诗蔻 | 2353240 | 18980433878 | 2987991635@qq.com     |
| 王奕昕 | 2353733 | 18966812958 | 807576942@qq.com     |
| 林青滢 | 2354356 | 15259577899 | 2354356@tongji.edu.cn |

## 项目概述

### 项目背景

近年来，随着生活节奏加快与数字压力增加，越来越多玩家倾向于选择节奏舒缓、画面治愈的 “慢游戏” 来放松身心。以《星露谷物语》为代表的农场模拟类游戏，凭借其自由度高、玩法丰富、情感细腻的特点，成为独立游戏领域的现象级作品。这类游戏不仅融合了种植、养殖、建造、社交、探索等多种元素，还通过四季更替、昼夜循环和 NPC 日常行为等机制，构建出一个富有生命力的虚拟乡村世界，让玩家在耕耘与陪伴中获得成就感与情感共鸣。

在此背景下，项目通过实现一个具备完整农场生态、角色交互与场景切换功能的 2D 模拟游戏，将玩家置身于一个充满生机与温情的像素风乡村世界，在播种与收获中感受时间的流逝，在与村民的互动中体会人情的温暖，真正实现“逃离都市，回归田园”的游戏愿景。

### 项目简介

本项目是一款基于 Cocos2d-x 3.17.2 引擎开发的 2D 农场模拟游戏，灵感来源于经典独立游戏《星露谷物语》。游戏以像素风格呈现，玩家扮演一名来到乡村生活的主角，在一片待开垦的土地上开启全新的田园生活。

游戏包含多个可探索区域，支持场景无缝切换与角色位置记忆；NPC具备基本 AI 行为，可在限定范围内移动并与玩家触发对话；同时设计了背包系统、签到界面、钓鱼小游戏等辅助功能模块，提升游戏丰富度。在视听层面，项目集成了背景音乐、环境音效、UI 动画与天气效果，营造沉浸式的乡村氛围。

本项目在忠实还原经典农场模拟玩法的基础上，融入多项创新与增强功能，打造出兼具趣味性与沉浸感的乡村生活体验。主要特色包括：

- **沉浸式农场经营系统**：完整实现作物从播种、浇水、生长到收获的全周期管理，结合昼夜更替与天气变化，营造真实农耕节奏。  
- **可交互 NPC 与剧情触发**：村民与动物具备基础 AI 行为，玩家靠近时可触发对话，未来可扩展任务与好感度系统。  
- **多功能背包与物品管理**：设计多页签背包界面，支持物品拖拽、分类查看与使用操作，提升资源管理效率。  
- **多场景无缝切换**：通过场景状态管理器，实现农场、房屋、湖泊等区域间的平滑跳转，并自动保存与恢复玩家位置。  
- **丰富休闲玩法**：集成每日签到、钓鱼小游戏、动物互动等轻量级模块，增加日常游玩的多样性与乐趣。  
- **温馨视听体验**：搭配舒缓背景音乐、动态环境粒子及流畅 UI 动效，构建治愈系像素风世界。

这些特色共同构成了一个自由、温暖且富有生命力的虚拟田园，让玩家在耕耘与探索中感受慢生活的魅力。

### 项目主要功能
1. **菜单系统**：
* 游戏入口和导航，负责游戏的启动、导航和基本设置。它提供了一个友好的用户界面，让玩家能够轻松地访问游戏的各个功能模块。菜单系统包括主菜单、设置菜单、关于菜单等多个子菜单。
2. **农场场景**：
* 主要游戏区域，场景包含了一个完整的农场环境，含有地形、建筑、农作物、动物等各种游戏对象，支持多层地图和碰撞检测。
3. **角色系统**：
* 玩家可以通过控制角色来与游戏世界交互。角色系统包括角色属性、角色动作、角色状态等多个方面。角色会随着游戏的进行而升级。
4. **动物系统**：
* 动物系统管理农场上的各种动物，每个动物都有一些基本属性。
5. **种植系统**：
* 这个系统模拟了真实的农业过程，包括种植、生长、收获等阶段。农作物会随着游戏时间的推移而生长，玩家需要照料农作物以确保其正常生长。
6. **时间系统**：
* 游戏有自己的时间系统，与现实世界的时间不同。游戏时间流逝的速度可以配置，通常比现实时间快得多。时间系统包括分钟、小时、天、季节等多个时间单位。
7. **场景系统**：
* 游戏不是在一个单一的大场景中进行的，而是由多个不同的场景组成。每个场景都有自己的地图、对象、逻辑等。场景系统负责场景之间的切换、资源加载和卸载等。
8. **音频系统**：
* 音频系统提供了播放、暂停、停止、调整音量等功能。游戏中的不同场景和事件都有相应的音频，音频系统负责在适当的时机播放这些音频。游戏中各种事件和操作产生不同的音效。



## 使用设计模式的重构

### 使用创建型模式重构

### **采用生成器模式重构角色动画系统**
#### 原有问题

**1. 创建/销毁频繁导致性能抖动**

* 工具动画（用斧头、镐子）每次调用都 `Sprite::create()` → 播放 → `removeFromParent()`。

```cpp
void CharacterWithTools::usetools(const std::string& filename) 
{ 
    auto tool = Sprite::create(filename); 
	……
	DelayTime::create(0.1f), CallFunc::create([tool]() { tool->removeFromParent(); }), 
	nullptr )); 
}
```
* 作物被种植 / 收割后重新创建，导致频繁分配与释放。

**2. 状态残留问题频发**

不同对象（工具、作物）被复用时，若未正确重置：

* Texture 仍旧是上一次的。
* Action 未停止。
* 调度器（scheduleUpdate）仍在运行。
* Visible、Scale、Rotation 可能处于旧状态。

**3. 维护成本高**

创建、销毁、初始化逻辑分散在代码很多处：

* `Sprite::create()`
* `removeFromParent()`
* `stopAllActions()`
* `setVisible(false)`
* `unscheduleUpdate()`

开发者容易忘记某些步骤，导致复用出现错误。

#### 重构的必要性
本次重构同时覆盖动画系统存在创建方式重复、初始化复杂、属性硬编码、扩展性弱的问题，使用生成器模式可将动画构建逻辑统一封装，避免重复创建流程，仅需指定prefix（路径）、frames（帧范围）、delay（速度），且链式调用能提高代码可读性，便于扩展。

#### UML类图
<p align="center">
  <img src="diagram/CharacterWithTools.svg" alt="Presentation Layer" style="width:80%; max-width:1200px; height:auto;"/>
</p>

#### 重构步骤

1. **新增 AnimationBuilder 类**：  
```cpp
class AnimationBuilder {
public:
    std::string prefix;
    int s, e;
    float delayUnit;

    AnimationBuilder& from(const std::string& p) { prefix = p; return *this; }
    AnimationBuilder& frames(int a, int b) { s = a; e = b; return *this; }
    AnimationBuilder& delay(float d) { delayUnit = d; return *this; }

    Animation* build() {
        auto anim = Animation::create();
        for (int i = s; i <= e; i++) {
            anim->addSpriteFrameWithFile(prefix + std::to_string(i) + ".png");
        }
        anim->setDelayPerUnit(delayUnit);
        anim->setLoops(-1);
        return anim;
    }
};
```
2. **角色类中使用 Builder 构建动画**
* 所有方向动画创建逻辑统一化、链式调用清晰。
```cpp
walkLeftAnimation = AnimationBuilder()
                        .from("character/Danaleft")
                        .frames(1, 3)
                        .delay(0.1f)
                        .build();
walkLeftAnimate = Animate::create(walkLeftAnimation);
walkLeftAnimate->retain();
```  

#### 改进与收益
使用生成器模式重构动画创建部分，有效解决重复代码、扩展性差、灵活性不足的问题；动画创建逻辑与角色逻辑解耦，维护和扩展成本显著降低。  
1. **避免重复**：改进后动画逻辑封装在 `Builder` 中，避免重复编写动画创建代码。
2. **逻辑解耦**：动画构建独立成类，职责清晰，与角色逻辑解耦。
3. **维护简便**：任何动画资源修改只需更改对应的 `Builder` 类并调用即可。
4. **扩展成本极低**：添加新动画仅需一行 `Builder` 调用。

---

### **采用工厂模式重构动物与作物系统**

#### **原有问题**
**1. 接口不一致，初始化方式分散**

动物（`Sheep`、`Cow`、`Parrot` 等）与作物（`Wheat`、`Corn`、`Tomato` 等）都存在类似问题：

```cpp
static Sheep* create(const std::string& filename);
bool Sheep::init(const std::string& filename);

static Crop* create(const std::string& filename);
bool Crop::init(const std::string& filename);
```
问题：

* 每个子类都必须自己实现 `create()` 和 `init()`
* 初始化流程分散在不同类中，违反 “开闭原则”

**2. 对象创建与业务逻辑混杂**

动物创建与初始化（如设置速度、边界、动画前缀）逻辑未分离，业务代码中需关注过多创建细节。

不同动物的创建流程重复，如create方法中的内存分配、初始化调用、自动释放池管理等步骤一致但重复编写。

**3. 扩展性差且维护成本高**

新增动物类型时，需同时修改创建调用的多处代码，易遗漏且增加出错风险。
* 添加类
* 写新的 `init`
* 写新的 `create`
* 业务逻辑中手动调用 `Sheep::create()` 或 `Wheat::create()`


无法统一管理动物创建过程，若需对创建逻辑进行全局调整（如添加日志、缓存），需逐个修改每个动物类的create方法。

#### **重构必要性**
如果不进行重构，系统将长期面临一系列严重问题：`create`/`init` 逻辑需要在几十个地方重复编写，导致代码冗余且难以维护；每当新增一种动物或作物类型时，必须同时修改多处代码，造成高度耦合，极大增加了出错风险；更关键的是，当前架构无法支持数据驱动的设计，使得动物和作物系统的扩展必须依赖硬编码，大幅抬高了后续功能迭代的成本。

因此，使用工厂模式将动物创建逻辑抽象并封装，通过统一的工厂接口创建对象，隔离具体类的依赖，新增动物类型时仅需扩展工厂类，无需修改原有代码，同时统一管理创建流程，降低维护成本。

#### UML类图
<p align="center">
  <img src="diagram/Factory.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>


#### **重构步骤**

1. **定义抽象工厂与具体工厂类**

 ```cpp
 class AnimalFactory {
    public:
    virtual ~AnimalFactory() = default;
    virtual Animal* createAnimal(const std::string& filename) = 0;
 };

  class SheepFactory : public AnimalFactory {
    public:
    Animal* createAnimal(const std::string& filename) override;
 };
……
 ```
2. **实现工厂管理器统一管理创建**

 ```cpp
class AnimalFactoryManager {
    private:
    static std::unordered_map<std::string, std::unique_ptr<AnimalFactory>> factories;
    public:
    static void registerFactory(const std::string& animalType, std::unique_ptr<AnimalFactory> factory);
    static Animal* createAnimal(const std::string& animalType, const std::string& filename);
    static void initializeFactories();
};
 ```
3. **业务代码中通过工厂管理器创建动物**
```cpp
 AnimalFactoryManager::initializeFactories();
 Animal* sheep = AnimalFactoryManager::createAnimal("sheep", "sheep.png");
……
```
#### **改进与收益**

使用工厂模式重构动物创建系统后，实现了创建逻辑的抽象与业务代码的解耦，具体改进体现在以下几个方面：

1. **解耦创建**: 通过引入工厂接口，业务代码不再直接依赖具体的动物类，而是面向抽象接口 AnimalFactory 与 Animal 编程，降低了代码耦合度。

2. **便于扩展**: 当需要新增动物时，只需实现对应的具体工厂类并注册到工厂管理器即可，无需修改现有创建逻辑，符合“开闭原则”，提高了系统的扩展性。

3. **集中管理**: 将原本分散在各处的重复创建代码统一封装在工厂类中，由工厂管理器集中管理所有工厂，提升了代码复用性和内聚性。

4. **全局控制**: 在工厂类或工厂管理器中可方便地加入日志记录、对象缓存、权限校验等统一逻辑，便于对创建过程进行集中管控。

通过以上改进，系统有效解决了对象创建过程中的耦合问题，显著提升了可维护性和灵活性，同时降低了后续维护的成本与风险。


## 使用结构型模式重构
### 采用外观模式重构场景管理器
#### 原有问题
**1. 场景切换逻辑分散**
场景创建和切换逻辑分散在多个文件中，每个场景类都需要直接调用 `Director` 和创建其他场景，导致代码重复且难以维护：

```cpp
// AppDelegate.cpp - 重构前：直接创建并运行场景
bool AppDelegate::applicationDidFinishLaunching() {
    auto director = Director::getInstance();
    auto glview = director->getOpenGLView();
    if (!glview) {
        glview = GLViewImpl::create("Valley Game");
        director->setOpenGLView(glview);
    }
    
    register_all_packages();
    
    // 直接调用 valleybegin 和 Director
    auto scene = valleybegin::createvalleybeginScene();
    director->runWithScene(scene);
    
    return true;
}

// valleybegin.cpp - 重构前：直接创建菜单场景
void valleybegin::Startgame(Ref* obj) {
    // 直接依赖 menu 类和 Director
    Scene* scene = menu::createmenuScene();
    Director::getInstance()->replaceScene(
        TransitionCrossFade::create(0.5, scene)
    );
    timerunning = true;
}

// menu.cpp - 重构前：直接创建农场场景
void menu::onMapRadioButtonSelected(RadioButton* radioButton, int index) {
    selectedMapIndex = index;
    log("Selected Map Index: %d", selectedMapIndex);
    
    // 直接依赖 outside 类和 Director
    auto newScene = outside::createSceneWithMapIndex(selectedMapIndex);
    Director::getInstance()->replaceScene(newScene);
}

// outside.cpp - 重构前：直接创建房屋和其他区域场景
void outside::loadMapBackground(int mapIndex) {
    // ... 地图加载逻辑 ...
    
    // 检测角色进入房屋区域
    if (characterPosition.x >= 3460 && characterPosition.x <= 3500 &&
        characterPosition.y >= 3570 && characterPosition.y <= 3610) {
        // 直接依赖 intovalley 类和 Director
        Scene* scene = intovalley::createintovalleyScene();
        Director::getInstance()->pushScene(scene);
        inZones["zone1"] = true;
    }
    
    // 检测角色进入其他区域
    if (characterPosition.x >= 3000 && characterPosition.x <= 3060 &&
        characterPosition.y >= 4740 && characterPosition.y <= 4770) {
        // 直接依赖 othersence 类和 Director
        Scene* scene = othersence::createothersenceScene();
        Director::getInstance()->pushScene(scene);
        inZones["zone2"] = true;
    }
}

// intovalley.cpp - 重构前：直接返回场景
void intovalley::init() {
    // ... 初始化逻辑 ...
    
    button->addClickEventListener([&](Ref* sender) {
        // 直接调用 Director 返回
        Director::getInstance()->popScene();
    });
}

// othersence.cpp - 重构前：直接返回场景
void othersence::init() {
    // ... 初始化逻辑 ...
    
    button->addClickEventListener([&](Ref* sender) {
        // 直接调用 Director 返回
        Director::getInstance()->popScene();
    });
}
```

**2. 紧耦合设计**
每个场景类都直接依赖 `cocos2d::Director` 和其他场景类，形成复杂的依赖网络。场景类之间相互依赖，修改一个场景类可能影响多个其他类。

**3. 违反单一职责原则**
场景类既要处理自身的业务逻辑（如角色移动、NPC交互），又要负责场景切换的基础设施逻辑（调用 Director、创建其他场景），职责混乱。

**4. 难以测试和维护**
场景切换逻辑与 Director 单例紧耦合，难以进行单元测试。修改场景切换逻辑需要在多个文件中进行修改，维护成本高。

**5. 代码重复**
相同的 Director 调用模式（`runWithScene`、`replaceScene`、`pushScene`、`popScene`）在多个文件中重复出现，违反 DRY 原则。

#### 重构的必要性

如果不进行重构，系统将面临以下问题：场景切换逻辑分散在 6 个不同的文件中，每次修改都需要在多个地方同步更新，容易遗漏且引入不一致性；每个场景类都直接依赖 Director 和其他场景类，形成高度耦合的依赖网络，任意一个场景类的改动都可能影响其他类；随着场景数量增加，这种分散的切换逻辑会导致代码越来越难以维护，违反开闭原则。

因此，使用外观模式将场景管理逻辑集中到 `GameSceneFacade` 类中，提供统一的接口来管理所有场景的创建和切换，隐藏与 Director 交互的复杂性，降低场景类之间的耦合度，使系统更易于维护和扩展。

#### UML类图
<p align="center">
  <img src="diagram/Facade.svg" alt="Facade Pattern UML" style="width:100%; max-width:1200px; height:auto;"/>
</p>

#### 重构步骤

1. **创建 GameSceneFacade 外观类**：

* 定义统一的场景管理接口，封装所有场景切换逻辑：

```cpp
class GameSceneFacade {
public:
    // 启动游戏，运行开场场景
    static void runWithBeginScene();
    
    // 从开场场景切换到菜单场景（带过渡动画）
    static void showMenuScene();
    
    // 从菜单场景进入农场场景
    static void enterFarmScene(int mapIndex);
    
    // 从农场场景进入房屋场景
    static void enterHouseScene();
    
    // 从农场场景进入其他区域场景
    static void enterOtherAreaScene();
    
    // 从子场景返回到上一个场景
    static void returnToPreviousScene();
};
```

2. **实现 GameSceneFacade 方法**：

* 在 `GameSceneFacade.cpp` 中实现所有方法，统一封装对 Director 的调用：

```cpp
void GameSceneFacade::runWithBeginScene() {
    auto scene = valleybegin::createvalleybeginScene();
    Director::getInstance()->runWithScene(scene);
}

void GameSceneFacade::showMenuScene() {
    Scene* scene = menu::createmenuScene();
    Director::getInstance()->replaceScene(
        TransitionCrossFade::create(0.5, scene)
    );
}

void GameSceneFacade::enterFarmScene(int mapIndex) {
    auto newScene = outside::createSceneWithMapIndex(mapIndex);
    Director::getInstance()->replaceScene(newScene);
}

void GameSceneFacade::enterHouseScene() {
    Scene* scene = intovalley::createintovalleyScene();
    Director::getInstance()->pushScene(scene);
}

void GameSceneFacade::enterOtherAreaScene() {
    Scene* scene = othersence::createothersenceScene();
    Director::getInstance()->pushScene(scene);
}

void GameSceneFacade::returnToPreviousScene() {
    if (Director::getInstance()->getRunningScene()) {
        Director::getInstance()->popScene();
    }
}
```

3. **重构所有场景切换调用**：

* 将所有直接调用 `Director` 和创建场景的代码替换为对 `GameSceneFacade` 的调用：

```cpp
// AppDelegate.cpp - 重构前
auto scene = valleybegin::createvalleybeginScene();
director->runWithScene(scene);

// AppDelegate.cpp - 重构后
GameSceneFacade::runWithBeginScene();

// valleybegin.cpp - 重构后
void valleybegin::Startgame(Ref* obj) {
    GameSceneFacade::showMenuScene();
}

// menu.cpp - 重构后
void menu::onMapRadioButtonSelected(...) {
    GameSceneFacade::enterFarmScene(selectedMapIndex);
}

// outside.cpp - 重构后
if (!inZones["zone1"]) {
    GameSceneFacade::enterHouseScene();
    inZones["zone1"] = true;
}
```

#### 改进与收益

使用外观模式重构场景管理后，实现了场景切换逻辑的集中管理，带来以下改进：

| 问题 | 改进后 |
| ---------------- | ---------------------- |
| 场景切换逻辑分散在 6 个文件中 | 所有场景切换逻辑集中在 `GameSceneFacade` 中 |
| 每个场景类直接依赖 Director 和其他场景类 | 场景类只依赖 `GameSceneFacade`，降低耦合度 |
| 场景类职责混乱（业务逻辑 + 基础设施逻辑） | 场景类专注业务逻辑，基础设施逻辑由 Facade 处理 |
| 难以测试和维护 | 场景切换逻辑集中，易于测试和维护 |
| 代码重复（Director 调用模式重复） | Director 调用统一封装在 Facade 中，消除重复 |

**核心优势：**

1. **降低耦合度**：
   - 重构前：6 个文件直接依赖 `Director`
   - 重构后：只有 1 个文件（`GameSceneFacade`）依赖 `Director`
   - 减少了 83% 的 Director 依赖
2. **集中管理**：
   - 所有场景切换逻辑在一个地方管理
   - 完整的游戏流程在 `GameSceneFacade` 中清晰可见
   - 易于理解和修改场景流程
3. **更好的可维护性**：
   - 添加新场景只需在 `GameSceneFacade` 中添加方法
   - 修改场景切换逻辑只需修改一个文件
   - 其他场景类无需修改
4. **清晰的职责分离**：
   - 场景类：关注"何时"切换（游戏规则）
   - `GameSceneFacade`：关注"如何"切换（`Director` 调用）
   - 符合单一职责原则
5. **更易测试**：
   - 可以通过 Facade 接口测试场景切换
   - 可以模拟 `GameSceneFacade` 进行测试
   - 集中化的逻辑更容易测试
6. **未来增强**：
   - Facade 可以扩展为记录场景切换日志
   - 可以添加分析追踪
   - 可以引入状态机模式
   - 可以支持命令模式（撤销/重做）

有效解决场景管理逻辑分散、耦合度高、难以维护的问题；场景切换逻辑与业务逻辑解耦，维护和扩展成本显著降低。

---
### 采用适配器模式重构场景管理器
#### 原有问题
1. **接口不一致**：
* 上层调用方无法依赖统一接口，只能逐个调用具体类，导致调用代码冗余且不易维护。随着场景增加，这种不统一会造成大量重复判断与分支逻辑，使创建流程更加混乱。
```cpp
// 不同场景的创建方法接口不统一
valleybegin::createvalleybeginScene()        // 无参数
menu::createmenuScene()                      // 无参数
outside::createSceneWithMapIndex(int)        // 需要参数
intovalley::createintovalleyScene()          // 无参数
othersence::createothersenceScene()          // 无参数
```
   
2. **高耦合**：
* `GameSceneFacade` 与所有具体场景类直接关联，形成强耦合。任意一个场景类的改动（文件名、方法名、构造参数）都会迫使 `GameSceneFacade` 重新编译。这种结构不符合开闭原则。
```cpp
// GameSceneFacade.h 直接依赖所有场景类
#include "valleybegin.h"
#include "menu.h"
#include "outside.h"
#include "intovalley.h"
#include "othersence.h"
```
3. **难以扩展**：
* 添加新场景需要修改 `GameSceneFacade`，违反“对扩展开放，对修改关闭”的原则。
* 场景创建逻辑分散，随着场景数量增加，调用端的分支判断（if/else 或 switch）会越来越庞大，维护成本随之成倍提高。
* 无法添加统一的场景创建前处理（如资源预加载、参数验证等）
#### 重构必要性

#### UML类图
<p align="center">
  <img src="diagram/SceneAdapter.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

#### 重构步骤

1. **定义统一接口**：
```cpp
class ISceneCreator {
public:
    virtual ~ISceneCreator() = default;
    virtual Scene* createScene(const cocos2d::ValueMap& params) = 0;
    virtual std::string getSceneType() const = 0;
    virtual void preloadResources() {}
    virtual bool canCreateScene(const cocos2d::ValueMap& params) const {
        return true;
    }
};
```
2. **创建具体适配器**：
```cpp
// 农场场景适配器
class FarmSceneAdapter : public ISceneCreator {
public:
    Scene* createScene(const cocos2d::ValueMap& params) override {
        int mapIndex = 0;
        if (params.find("mapIndex") != params.end()) {
            mapIndex = params.at("mapIndex").asInt();
        }
        return outside::createSceneWithMapIndex(mapIndex);
    }
    ...
};
```
3. **适配器管理器**:
```cpp
class SceneAdapterManager {
private:
    std::map<std::string, ISceneCreator*> adapters;
public:
    static SceneAdapterManager* getInstance();
    void registerAdapter(const std::string& sceneType, ISceneCreator* adapter);
    Scene* createScene(const std::string& sceneType, const cocos2d::ValueMap& params = cocos2d::ValueMap());
};
```

4. **创建农场场景**:
```cpp
// 使用适配器，统一接口
ValueMap params;
params["mapIndex"] = Value(2);
Scene* farmScene = SceneAdapterManager::getInstance()->createScene("Farm", params);
```
5. **添加新场景**:
```cpp
// 1. 创建新场景适配器
class ShopSceneAdapter : public ISceneCreator {
public:
    Scene* createScene(const ValueMap& params) override {
        // 适配新的场景创建方法
        return ShopScene::createShopScene();
    }
    std::string getSceneType() const override { return "Shop"; }
};

// 2. 注册适配器（在 SceneAdapterManager 构造函数中）
registerAdapter("Shop", new ShopSceneAdapter());

// 3. 在 Facade 中添加方法（可选，也可以直接调用适配器）
void GameSceneFacade::enterShopScene() {
    Scene* scene = getAdapterManager()->createScene("Shop");
    Director::getInstance()->pushScene(scene);
}
```
6. **场景预加载**:
```cpp
// 在进入场景前预加载资源
void GameSceneFacade::enterFarmScene(int mapIndex) {
    // 预加载农场场景资源
    getAdapterManager()->preloadSceneResources("Farm");
    
    // 创建场景
    ValueMap params;
    params["mapIndex"] = Value(mapIndex);
    Scene* scene = getAdapterManager()->createScene("Farm", params);
    // ...
}
```
#### 改进与收益
1. **统一接口**：
通过引入统一的 `createScene(sceneName, params)` 接口，调用方无需再关注不同场景的构造方式、参数差异或初始化流程，只需要传入场景名和参数即可。  这种接口统一不仅减少业务层判断逻辑，也让上层代码更加清晰、直观、易维护。
2. **解耦合**：
`GameSceneFacade` 不再直接依赖各个具体场景类，而只依赖抽象接口 `ISceneCreator`。  这降低了模块之间的耦合度，使 `Facade` 不再受到场景类变动的影响，也可以在无需修改业务代码的情况下新增或替换场景实现。符合依赖倒置原则。
3. **易于扩展**：
通过适配器模式，每个新场景只需编写一个对应的适配器并注册即可生效。而不需要修改`GameSceneFacade` ，避免了传统结构中不断添加 `if/else` 或 `switch` 的冗余逻辑，使得新增场景的成本大幅降低，也便于开发者在后续迭代中引入更多场景类型，极大提升扩展性和系统灵活度。
4. **参数统一处理**：
不同场景可能需要不同参数，为避免接口分裂，将参数统一封装为 `ValueMap`，由适配器内部进行解析与转换。  这样既保证了外部调用的统一性，也为后续扩展提供了灵活性，例如支持更多参数、默认值处理、参数校验等。

### 使用行为模式重构

### 使用策略模式 + 状态模式重构动物行为状态和动画

#### 原有问题

1. **代码重复问题**：
* **DRY 原则违反**：相同的动画创建逻辑重复 3 次 。

* **维护困难**：动画参数分散在多个地方，修改一处需要改三处，容易遗漏且引入不一致性，最后需要大量的测试验证。

```cpp
bool Sheep::init(const std::string& filename){
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Sheep" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}

bool Cow::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Cow" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}

bool Parrot::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Parrot" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}


```

2. **缺乏行为抽象**：系统中不同对象的行为没有被抽象成接口或基类，而是硬编码在具体的类中
- **行为固定，无法扩展**：所有动物都使用相同的移动逻辑，无法为不同对象定制不同的行为，无法实现不同的移动方式。
- **难以测试**：行为与数据紧耦合，行为直接访问和修改数据成员，无法独立测试行为和数据，也无法重用行为。


```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta * speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

3. **状态管理混乱**：
- **状态隐式**：原始代码中没有显式的状态管理，动物的行为完全由 update() 方法决定
- **行为难以理解**：没有获取状态的方法，无法清晰地了解当前对象所处的状态。状态与数据混淆在一起，无法清晰地区分。
- **无法转换**：原始代码中，动物只能处于一种隐式的状态：移动到目标。无法灵活地在不同状态间切换。

```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta * speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

4. **紧耦合设计**：
<p align="center">
  <img src="diagram/Coupled p.svg" alt="Presentation Layer" style="width:70%; max-width:700px; height:auto;"/>
</p>

* 羊，牛，鹦鹉子类的`init()`函数与`Sprite` , `Animation` ,` Animate`类耦合，一个模块的改变会直接影响其他模块，产生修改涟漪效应，导致代码难以维护和扩展。在测试方面，无法单独隔离测试子类，且测试速度慢，测试不稳定。

5. **难以添加新的功能**：
* 所有动物行为都在单一的 `update()` 方法中，包括的职责有：计算方向，更新位置，检查距离，生成新目标。这是一个"上帝方法"，做的事情太多，让阅读者难以理解。添加新的功能后，代码会迅速膨胀，且条件判断复杂，违反“开闭原则”。

```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta *speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

6. **动画单一，视觉效果不佳**：
* 每个动物类型只有一种固定动画，暂时只有“默认行走”动画。无法体现不同行为的视觉差异，玩家将无法通过角色动作直观感知其行为意图——休息时仍在走动、追逐时速度无变化且动作无紧张感，严重削弱沉浸感与反馈清晰度，导致角色行为“表里不一”，降低游戏表现力与可信度。

#### 重构的必要性
* **业务需求驱动**：当前只有3 种动物（羊、牛、鹦鹉）， 1 种行为（游荡），1 种动画；而未来需要扩展更多种动物、行为种类（游荡、休息、追踪、觅食、逃跑）以及多种的动态动画切换。原始代码无法满足这些需求，重构后可以轻松扩展。
* **技术债务**：当代码重复率高达30-40%，代码中的决策点多，路径复杂，模块间耦合度高，容易有出错概率高，测试和维护难度越大。重构后可以降低维护成本，提高开发效率
* **开发效率**：原始代码添加新动物需要写 50+ 行重复代码，修改动画参数需要改 3 个地方，添加新行为需要修改 `update()` 方法，使得方法冗长。重构后添加新动物：只需写 10 行代码，修改动画参数只需改 1 个地方，添加新行为只需创建新状态类。效率提升效果明显。
* **游戏视觉**：原始代码的动物行为简单直接，适合开发初始阶段，可能美术资源未就位。重构后，在策略模式和行为模式的基础上，将动画与行为解耦，做到动物的动画展示随状态改变而改变，增强游戏的体验感和视觉享受。

#### UML类图
* 策略模式类图
<p align="center">
  <img src="diagram/Strategy.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

<br></br>

* 状态模式类图
<p align="center">
  <img src="diagram/State.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>


#### 重构步骤
为解决上述问题，将运用策略模式和状态模式，将"所有动物共享一套固定的初始化和移动逻辑"重构为"每个动物可以选择自己的动画策略和运动状态"。让代码更好地服务于业务，以便之后更高效地开发和维护。

1. **明确重构目标**：
* **遵循单一职责原则**：`Animal` 只负责持有状态/策略，重构其他类专注行为逻辑和视觉表现。
* **遵循开闭原则**：使得新增动物类型，新增移动行为，更换动画风格更加容易。
* **解耦具体实现，依赖抽象**：底层图形引擎变化时，`Animal` 几乎不用改。
* **行为与动画解耦**：每个动物支持三种行为状态，同一动物可拥有多个策略，按需切换。
2. **建立动画策略体系**：
* 新建 `AnimationStrategy.h`
* 定义抽象接口 `AnimationStrategy`
```cpp
class AnimationStrategy {
public:
    virtual ~AnimationStrategy() = default;
    virtual void applyAnimation(Sprite* sprite) = 0;
};
```
* 实现通用策略类 `GenericAnimationStrategy`，支持按前缀加载帧序列
```cpp
class GenericAnimationStrategy : public AnimationStrategy {
private:
    std::string prefix;   
    int frameCount;
    float delay;

public:
    GenericAnimationStrategy(const std::string& animPrefix, int count = 4, float d = 0.1f)
        : prefix(animPrefix), frameCount(count), delay(d) {}

    void applyAnimation(Sprite* sprite) override {
        auto animation = Animation::create();
        bool hasValidFrame = false;
        for (int i = 1; i <= frameCount; ++i) {
            std::string frameName = prefix + std::to_string(i) + ".png";
            auto frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(frameName);
            if (!frame) {
                auto texture = Director::getInstance()->getTextureCache()->addImage(frameName);
                if (texture) {
                    Rect rect = Rect::ZERO;
                    rect.size = texture->getContentSizeInPixels();
                    frame = SpriteFrame::createWithTexture(texture, rect);
                    hasValidFrame = true;
                }
            } else {
                hasValidFrame = true;
            }
            if (frame) {
                animation->addSpriteFrame(frame);
            }
        }

        if (!hasValidFrame) {
            CCLOG("Warning: No valid frames for animation prefix: %s", prefix.c_str());
            return;
        }

        animation->setDelayPerUnit(delay);
        animation->setLoops(-1); // loop forever
        auto animate = Animate::create(animation);
        sprite->stopAllActions();
        sprite->runAction(animate);
    }
};
```

3. **定义行为状态机**：
* 新建 `AnimalState.h`
* 声明抽象基类 `AnimalState`
```cpp
class AnimalState {
public:
    virtual ~AnimalState() = default;
    virtual void enter(Animal* animal) = 0;
    virtual void update(Animal* animal, float delta) = 0;
    virtual void exit(Animal* animal) = 0;
    virtual std::string getName() const = 0;
};
```
* 实现三种具体状态：
    * `WanderingState`：随机移动 + wander 动画
    * `ChasingState`：朝目标移动 + chase 动画（可设追逐点）
    * `RestingState`：静止 + rest 动画，3 秒后自动切回 wandering
```cpp
// ------------------ Wandering ------------------
class WanderingState : public AnimalState {
public:
    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            std::make_unique<GenericAnimationStrategy>(animal->getAnimPrefix() + "_wander")
        );
        animal->generateNewTarget();
    }

    void update(Animal* animal, float delta) override {
        Vec2 dir = animal->getTargetPosition() - animal->getPosition();
        if (dir.length() < 10.0f) {
            animal->generateNewTarget();
        } else {
            animal->setPosition(animal->getPosition() + dir.getNormalized() * animal->getSpeed() * delta);
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Wandering"; }
};

// ------------------ Chasing ------------------
class ChasingState : public AnimalState {
private:
    Vec2 chaseTarget;
public:
    void setChaseTarget(const Vec2& target) { chaseTarget = target; }

    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            std::make_unique<GenericAnimationStrategy>(animal->getAnimPrefix() + "_chase")
        );
    }

    void update(Animal* animal, float delta) override {
        Vec2 dir = chaseTarget - animal->getPosition();
        if (dir.length() > 5.0f) {
            animal->setPosition(animal->getPosition() + dir.getNormalized() * animal->getSpeed() * 1.8f * delta);
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Chasing"; }
};

// ------------------ Resting ------------------
class RestingState : public AnimalState {
private:
    float restTime = 0.0f;
    const float MAX_REST = 3.0f;

public:
    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            std::make_unique<GenericAnimationStrategy>y(animal->getAnimPrefix() + "_rest")
        );
        restTime = 0.0f;
    }

    void update(Animal* animal, float delta) override {
        restTime += delta;
        if (restTime >= MAX_REST) {
            animal->changeState(std::make_unique<WanderingState>());
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Resting"; }
};

```

4. **改造 Animal 基类**：
* 在 `Animal.h` 中：
    * 添加成员：`unique_ptr<AnimalState> currentState` 和 `unique_ptr<AnimationStrategy> currentAnimation`
    * 添加方法：`changeState()`、`setAnimationStrategy()`
    * 声明虚函数 `getAnimPrefix()` 供子类指定资源前缀

```cpp
class Animal : public Sprite {
protected:
    Vec2 targetPosition; 
    Rect Bounds;
    float speed;
    std::string animPrefix;

    std::unique_ptr<AnimalState> currentState;
    std::unique_ptr<AnimationStrategy> currentAnimation;

public:
    Animal();
    virtual ~Animal();
    static Animal* create(const std::string& filename);
    virtual bool init(const std::string& filename) = 0;

    void generateNewTarget();
    void update(float delta);

    // State & Animation Control
    void changeState(std::unique_ptr<AnimalState> newState);
    void setAnimationStrategy(AnimationStrategy* strategy);

    // Getters
    Vec2 getTargetPosition() const { return targetPosition; }
    void setTargetPosition(const Vec2& pos) { targetPosition = pos; }
    float getSpeed() const { return speed; }
    const std::string& getAnimPrefix() const { return animPrefix; }
    const Rect& getBounds() const { return Bounds; }
};
```
* 在 `Animal.cpp` 中：
    * 实现 `update()` 转发给当前状态
    * 实现状态切换逻辑（调用 exit → enter）
    * 在 `setAnimationStrategy()` 中应用新动画并停止旧动作
```cpp
void Animal::update(float delta) {
    if (currentState) {
        currentState->update(this, delta);
    }
}

void Animal::changeState(std::unique_ptr<AnimalState> newState) {
    if (currentState) {
        currentState->exit(this);
    }
    currentState = std::move(newState);
    if (currentState) {
        currentState->enter(this);
    }
}

void Animal::setAnimationStrategy(AnimationStrategy* strategy) {
    currentAnimation.reset(strategy);
    if (strategy && this->isRunning()) {
        strategy->applyAnimation(this);
    }
}
```

5. **更新具体动物类**
* 修改 `Sheep`、`Cow`、`Parrot` 的构造函数：
    * 设置各自的 `animPrefix`
    * 初始化时调用 `changeState(std::make_unique<WanderingState>())`
* 移除原有硬编码动画逻辑

```cpp
bool Sheep::init(const std::string& filename){
   if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Sheep image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Sheep";
    changeState(std::make_unique<WanderingState>());
    return true;
}

```
```cpp
bool Cow::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Cow image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Cow";
    changeState(std::make_unique<WanderingState>());
    return true;
}
```

```cpp
bool Parrot::init(const std::string& filename) {
     if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Parrot image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Parrot";
    changeState(std::make_unique<WanderingState>());
    return true;
}
```

#### 改进与收益
1. **降低代码重复率**：
* 原来每个子类都要自己创建动画，但创建逻辑完全相同。子类继承了基类的所有代码，但无法复用基类的逻辑，只能重复实现。用抽象层进行集中管理后，可以避免在许多地方重复编写相同的代码
2. **降低耦合度**：
* 重构后 `Animal` 耦合 `AnimationStrategy` 和 `AnimalState` ，与 `Sprite` 、`Animation` 、`Animate` 松耦合。Animal 只负责“动物”的高层逻辑，动画和移动细节交给策略/状态，符合单一职责原则。
3. **增强扩展性**：
* 添加新的动物行为状态，只需要在 `AnimalState.h` 中新增状态类。代码可以在运行时改变动画策略和状态。
4. **提高代码的可读性**：
* 将策略和状态独立成类，使得代码结构更加清晰，意图明确，需要注释的地方减少。
5. **“状态”真正驱动“表现”**:
* 动画策略与“状态”对齐，而非与“动物类型”绑定。每个动物支持三种行为状态，同一动物可拥有多个策略，按需切换。状态切换时自动切换对应动画，动画资源与行为状态一一对应，清晰明确使用带参数的通用策略，而非为每种组合创建新类，可以防止类的爆炸

---
### 使用观察者模式重构

#### 原有问题

1. **作物成熟逻辑与 UI 逻辑耦合**：
* **紧耦合**：作物成熟发生后，直接在此类内部执行贴图更新与 UI 表达，可视化层与业务层混杂，无法复用与扩展。
* **缺乏事件对外通知机制**：成熟事件只在自身内部被处理，任务系统、统计系统、音效模块无法获知该事件，新需求必须直接修改此类，违反开放封闭原则。


```cpp
if (state == State::growing) {
    growthTime += delta;
    if (growthTime >= matureTime) {
        state = State::matured;
        this->setTexture("plant/matured.png");   
        log("Crop matured!");                    
    }
}
```

2. **自动收获逻辑简陋**：
* **无信号提示**：自动收获后没有向系统发出任何信号，UI 不会显示消失提示，音效不触发，任务计数不会更新。
* **事件语义无法区分**：系统无法区分手动收获和自动收获或凋零的事件类型。

```cpp
else if (state == State::matured) {
    growthTime += delta;
    if (growthTime >= matureTime * 3) {
        state = State::harvested;
        this->setTexture("plant/cropharvested.png");
    }
}
```

3. **时间推移与 UI 强耦合**
* **违反了单一职责原则**：`outside` 既负责时间系统，又负责 UI 展示，承担多重职责。
* **UI 依附于 outside**：若未来加入 `InDoorScene` 或 `TownScene` 必须复制同样逻辑，代码重复严重。

```cpp
void outside::updateTime(float dt) {
    totalTime += dt;
    if (totalTime >= 60) {
        minute++;
        totalTime = 0;
        auto label = dynamic_cast<Label*>(getChildByName("timeLabel"));
        label->setString(StringUtils::format("%d", minute));  // 直接操作UI
    }
}
```

#### 重构必要性

当前 `valley-main` 的事件系统紧耦合、难扩展、事件传播链不完整。因此有必要引入观察者模式，将事件发布与事件处理解耦，实现统一事件流转。
观察者模式通过 `EventCenter` 统一管理事件订阅与分发，实现：
- 事件从触发源传播到多个观察者
- 事件逻辑与表现逻辑分离
- 支持模块动态扩展，不需要修改现有代码
从而显著提高系统扩展性与维护性。

#### UML类图

* 观察者模式类图
<p align="center">
  <img src="diagram/ObserverPatternUML.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

#### 重构步骤

为了使用观察者模式重构 valley-main 的事件系统，我们将事件处理逻辑从作物、时间系统、UI 管理器等类中解耦出来，使它们只负责状态变更和事件发布，而事件处理由观察者统一承担。当前版本的系统中，除了作物之外，时间事件由独立的 TimePublisher 负责产生，并通过全局的 EventCenter 广播给 outside、UIManager 等观察者。

1. **定义观察者接口**

* 创建一个 `Observer` 接口，定义所有观察者需要实现的方法。

```cpp
class Observer {
public:s
    virtual ~Observer() = default;
    virtual void onNotify(const EventData& event) = 0;
};
```


2. **定义事件类型与事件数据结构**

* 实现事件系统所需的枚举类型与事件封装对象。

```cpp
enum class EventType {
    MinuteChanged,
    CropMatured,
    CropHarvested,
    CropDead
};

class EventData {
public:
    EventType type;
    void* sender;

    EventData(EventType t, void* s) : type(t), sender(s) {}
};
```


3. **创建统一事件中心**

* 将事件中心设计成被观察者，负责维护观察者列表，并在事件发布时通知观察者。`EventCenter` 被设计为全局单例，确保系统中所有事件源与观察者始终共享同一个事件中心。

```cpp
class EventCenter {
public:
    static EventCenter* getInstance();

    void attach(Observer* obs) { observers.pushBack(obs); }
    void detach(Observer* obs) { observers.eraseObject(obs); }

    void publish(EventType type, void* sender) {
        EventData event(type, sender);
        for (auto obs : observers) {
            obs->onNotify(event);
        }
    }

private:
    cocos2d::Vector<Observer*> observers;
};
```

4. **修改 Crop 类**：

* 所有原本直接修改 UI 的逻辑被移除，改为发布事件，由观察者统一响应。


```cpp
if (state == State::matured) {
    // add：发布成熟事件
    EventCenter::getInstance()->publish(EventType::CropMatured, this);
}
```

```cpp
void Crop::harvest() {
    state = State::harvested;

    // add：发布手动收获事件
    EventCenter::getInstance()->publish(EventType::CropHarvested, this);
}
```


5. **修改 outside 类：从“事件源”变为“观察者”**：
* outside 不再负责产生时间事件，只负责响应 UI 更新：

```cpp
class outside : public cocos2d::Layer, public Observer {
public:
    virtual void onNotify(const EventData& event) override;
};

```

* 示例响应：

```cpp
void outside::onNotify(const EventData& event) {
    if (event.type == EventType::MinuteChanged) {
        auto label = dynamic_cast<Label*>(getChildByName("timeLabel"));
        if (label) label->setString(this->getFormattedTime());
    }
}

```


6. **新增 UIManager 作为观察者**：
* UIManager 也是观察者，负责统一管理 UI 组件，例如作物提示、动画展示等。

```cpp
void UIManager::onNotify(const EventData& event) {
    if (event.type == EventType::CropMatured) {
        showMatureIcon(static_cast<Crop*>(event.sender));
    }
}

```

7. **观察者注册**：
* 在 outside::init() 中进行观察者注册，则 `outside` 成为全局事件系统的观察者，能够响应 Crop 和场景事件。
```cpp
bool outside::init() {
    EventCenter::getInstance()->attach(this);
    ...
    return true;
}
```
8. **引入时间事件源：TimePublisher**：
* 新增了 TimePublisher，用于统一管理时间流逝，并将时间变化事件发布给观察者。

* TimePublisher 并不承担 UI 更新，而是专注于事件发布：
```cpp
EventCenter::getInstance()->publish(EventType::MinuteChanged, this);

```
*这样，outside 或 UIManager 等观察者即可自由响应时间事件。

#### 改进与收益

1. **解耦与抽象**：通过定义 `Observer` 接口，将事件处理逻辑从作物类、场景类中彻底分离，使原本杂糅在内部的 UI 更新、任务处理等逻辑独立出来，形成清晰的观察者架构。
2. **单一职责原则**：`Crop 只负责生命周期与事件发布，TimePublisher 只负责时间推进与事件发布，outside/UIManager 只负责 UI 响应，职责边界明显，代码更加清晰。
3. **提高扩展性**：将来新增观察者时不需要修改 `Crop`、`outside` 等事件源代码，系统具备良好的可扩展性。
4. **动态事件响应机制**：`EventCenter` 支持运行时 `attach/detach` 观察者，使得系统可以灵活控制哪些功能启用或关闭。
5. **提升代码复用性**：统一事件入口`onNotify`与事件中心共享机制让 UI 更新、音效、任务统计等跨模块逻辑不再重复，相关处理集中在各自观察者类中。
6. **降低耦合度，系统结构更清晰**：事件源不再直接操作 UI，不再依赖外部模块代码，消除了"谁调用谁"的混乱引用，整体代码层次更加直观。
7. **未来支持更多事件类型**：无论新增节日触发、天气变化、NPC 行为等事件，只需定义新的 `EventType` 并在事件源发布，现有系统即可自动兼容。

## 使用课程未涉及的设计模式重构

### 使用对象池模式重构

#### 模式解释  
**对象池模式**是一种创建型设计模式，它通过**预先创建并复用一组初始化好的对象**，避免在运行时频繁地创建和销毁对象。当客户端需要对象时，从池中“借出”；使用完毕后，将对象“归还”到池中，而不是直接销毁。该模式特别适用于**创建成本高、使用频繁、生命周期短**的对象管理。

#### 核心思想  
- **复用优于重建**：对象不是用完就丢，而是回收再利用。  
- **资源预分配**：在系统空闲或启动时预先创建一批对象，减少运行时开销。  
- **控制资源总量**：通过池大小限制并发对象数量，防止内存爆炸。

#### 工作流程  
1. **初始化池**：创建一批对象，放入“空闲队列”。
2. **获取对象**：
   - 若空闲队列非空 → 取出一个对象，重置其状态（如位置、属性），返回给客户端。
   - 若队列为空 → 可选择：
     - 阻塞等待；
     - 动态创建新对象（可选）；
     - 抛出异常（严格池）。
3. **归还对象**：客户端调用 `release()`，对象被放回空闲队列（不清除内存）。
4. **销毁池**：程序结束时统一释放所有对象。

#### 优点  
* **提升性能** ：避免频繁 `new/delete` 或 `malloc/free` 的开销（尤其对复杂对象）。
* **减少内存碎片** ：对象地址相对固定，降低堆内存碎片化。 
* **控制资源使用** ：限制最大对象数，防止系统过载（如数据库连接池）。 
* **降低 GC 压力**：减少临时对象生成，减轻垃圾回收负担 。
* **提高响应速度**： 获取对象是 O(1) 操作，无初始化延迟 。

#### 缺点  
* **内存占用增加**：对象常驻内存，即使未使用也占用空间。
* **状态管理复杂**：归还对象必须彻底重置状态，否则会污染下一次使用。
* **线程安全问题**：多线程环境下需加锁，可能成为性能瓶颈。
* **不适合长生命周期对象**：若对象长期被占用，池的优势无法体现。
* **调试困难**：对象复用可能导致难以追踪的逻辑错误（如残留数据）。

#### 应用场景  
* **游戏开发**：子弹、粒子、敌人、动画对象（频繁创建/销毁）。
* **Web 后端**：数据库连接池（如 HikariCP）、HTTP 客户端池。
* **网络编程**：Socket 连接、缓冲区（Buffer）复用。
* **科学计算**：矩阵、向量等大型数据结构缓存。
* **移动端**：RecyclerView / ListView 的 ViewHolder 复用（Android）。
* **AI/仿真系统**：传感器数据包、事件对象池。

---

#### 原有问题
1. **资源耗尽风险**
- 每次请求或任务都创建新线程，线程数量可能无限制增长。
- 大量线程会耗尽内存，导致 `OutOfMemoryError`。

2. **性能开销大**
- 线程创建/销毁成本高，涉及内核调度、内存分配、上下文切换等。
- 频繁创建线程会导致 CPU 大量时间花在调度而非业务逻辑上。
- 响应延迟增加，吞吐量下降。

3. **缺乏控制与管理**
- 无法限制最大并发数，容易引发雪崩效应。
- 无法监控活跃线程数、任务队列状态。
- 无法优雅关闭、等待任务完成、拒绝过载任务等。

4. **缺乏高级功能支持**
- 无法实现定时任务、周期任务（需配合 `Timer` 或手动实现）。
- 不支持任务返回结果（`Future`）、超时控制、批量提交等。

#### 重构的必要性

**对象池** 能解决上述问题：

- 减少频繁创建/销毁，提高性能与稳定性

- `Sprite`/`Node` 复用后：

    * 分配次数大幅下降（一般减少 20～60 倍）
    * `Autorelease` 压力下降 → FSP 波动减少

- 统一重置对象状态，防止残留 Bug

- 从池中取出后统一调用，回收到池时统一恢复

#### UML类图
* 对象池类图
<p align="center">
  <img src="diagram/Action.svg" alt="Presentation Layer" style="width:80%; max-width:1200px; height:auto;"/>
</p>

#### 重构步骤

1. **取对象**:

```cpp
static Sprite* getPooledTool(const std::string& filename) {
    auto& list = toolPool[filename];

    if (!list.empty()) {
        Sprite* tool = list.back();
        list.pop_back();

        // 重置
        tool->stopAllActions();
        tool->setVisible(true);
        tool->setOpacity(255);
        tool->setRotation(0);
        tool->setScale(1.0f);

        return tool;
    }

    // 池为空 → 创建新对象
    Sprite* tool = Sprite::create(filename);
    tool->retain();  // 池内资源需要 retain
    return tool;
}
```
2. **回收对象**:

```cpp
static void recycleTool(Sprite* tool, const std::string& filename) {
    tool->stopAllActions();
    tool->setVisible(false);
    tool->removeFromParent();  // 可选（推荐）
    toolPool[filename].push_back(tool);
}
```
#### 改进与收益

1. 通过引入对象池机制重构后，在角色使用工具、种植作物及收获作物的操作场景中，实现了多维度的优化提升：

- 在工具使用环节，调用`getPooledTool`获取池化工具对象，使用后通过`recycleTool`回收；
- 种植作物时，调用`getPooledCrop`获取池化作物对象并执行`resetState`重置状态，收获阶段则调用`recycleCrop`回收作物对象。

2. 对象池的改造模式，带来了显著的效果提升：

- **性能层面**：原始实现因频繁动态创建和销毁对象，导致FPS出现明显抖动；重构后借助对象复用减少了内存分配操作，使得FPS表现更为稳定。

- **内存层面**：原先依赖`autorelease`机制管理对象，造成内存管理压力较大；重构后对象分配次数大幅降低（20～60倍），有效缓解了内存波动问题。

- **状态管理层面**：原始代码中对象复用易出现状态残留，引发常见Bug；重构后通过统一的`resetState`重置机制，确保对象状态干净，提升了系统稳定性。

- **可维护性层面**：原本对象的创建与删除逻辑分散在多处代码中，维护成本高；重构后将对象获取、回收等逻辑集中到对象池统一管理，代码结构更清晰，便于后续维护与扩展。


## AI工具使用情况的阐述

### 模式设计的探索和选择
* 项目初期，我们发现游戏各个模块（如时间、动物、植物）之间存在大量直接调用，代码高度耦合，难以维护。尤其是事件传播逻辑高度分散，`Crop` 直接操作 UI，`outside` 同时负责时间逻辑与 UI，导致业务逻辑与表现逻辑混杂在一起。随着需求增加（天气系统、节日活动、多场景 UI 页、成就统计等），原有架构已无法承载，需要一种能够统一事件流转、减少依赖的机制。
* 在探索设计思路的过程中，我们使用 AI 工具分析现有架构中耦合问题的根源，并参考其给出的模式选择建议。AI 工具展示了观察者模式的整体结构特点，并指出可以通过“事件中心—观察者”的方式统一模块间通信，减少跨模块引用。基于这一启发，我们选择采用观察者模式重构 `valley-main` 的事件流系统，并以 `EventCenter` 作为统一的事件调度核心。

### 具体代码的重构和生成
* 在具体代码重构过程中，AI 工具协助我们生成了一些基础骨架。例如，在动物模块中，每种动物仅有一种固定“默认行走”动画，则无法体现不同行为状态。我们尝试使用 AI 工具生成状态模式（State Pattern）的重构方案：AI 自动生成了 `AnimalState` 抽象接口以及 `ChasingState`、`WalkingState` 等基本状态类骨架。在此基础上，我们再结合 Cocos2d-x 的 API 进行了二次完善与功能填充，使得行为逻辑与状态管理得以解耦。
* 同样，在事件系统重构中，AI 协助我们生成了 `Observer` 接口、`EventData` 数据结构、事件中心的基本框架代码。这些模板代码使我们得以快速开始重构工作，并根据引擎环境进一步调适，使之符合 valley-main 的需求。

### 反思与讨论
* **最佳实践**: “我们发现 AI 在这一过程中最有效的角色是“结对编程的伙伴”。它能够快速提供设计模式的框架、生成样板代码、解释复杂结构，并辅助验证设计方向是否合理。但最终的架构决策、模块边界划分、引擎 API 适配仍需由我们主导完成。”
* **局限性**: “AI 无法理解 `valley-main` 的整体架构，也无法主动识别哪些类属于“上帝类”（例如早期的 `outside.cpp`）。同时，它的知识可能存在版本差异，生成的代码偶尔会使用已废弃或不兼容的 API。某些时候，AI 会给出理论上正确但在 Cocos2d-x 环境下无法直接运行的代码，需要人工修正。”
* **挑战与解决方案**: “最大挑战在于 AI 生成的代码不能直接投入项目使用。我们必须通过阅读 Cocos2d-x 官方文档、查阅具体类继承关系，并通过调试验证每个 API 的实际行为，才能确保最终代码正确运行。这个过程让我们认识到：人工判断和架构理解是核心，AI 更适合作为辅助工具。最终形成的流程是：由人制定设计，再利用 AI 生成可参考的骨架，再由人进行深度裁剪与调适。”

## 重构的价值主张：设计模式视角

### 创建型模式


### 结构型模式
这个方案巧妙地结合了两种结构型模式：
1. **外观模式 (Facade)**：
   - `GameSceneFacade` 提供统一的场景切换接口
   - 隐藏 `Director` 和场景创建的复杂性
2. **适配器模式 (Adapter)**：
   - `SceneAdapter` 统一不同场景的创建接口
   - 解耦 `GameSceneFacade` 与具体场景类
**两种模式相互配合，保持开闭原则，实现了更好的解耦和扩展性！**


### 行为模式
* 在初始重构阶段，我们采用了策略模式和状态模式进行代码改造。然而很快发现，由于每种动物仅有一种固定的“默认行走”动画，策略模式实际上形同虚设，导致动画与行为之间依然存在强耦合。即便我们创建了诸如 `SheepAnimationStrategy` 这样的类，一旦绵羊需要支持三种不同的动画，就不得不将所有相关逻辑塞进同一个策略类中，这明显违背了单一职责原则。而当我们采用更细粒度的设计时，状态模式的优势才真正显现：同一动物可以拥有多种状态，每种状态精确对应一种动画表现形式，逻辑清晰、职责分明。
* 因此，重构代码的目的绝不应止步于简单堆砌多种设计模式，而应让它们彼此协同、优势互补，注重它们之间的关系，是否清晰、协作是否顺畅，形成一套结构合理、职责清晰、可维护且可扩展的整体解决方案，从而实现设计上的完整与优雅。

## 总结
通过本次对整体项目代码的系统性重构，我们不仅解决了局部技术债，更建立起一套可持续演进的工程范式。以下是我们从实践中沉淀出的核心认知：
1. **设计模式必须服务于整体架构目标，而非孤立使用**：在早期重构中，我们曾零散地在不同模块套用策略、单例、观察者等模式，结果导致风格割裂、理解成本上升。后来我们统一以“分层+组合”为指导思想：底层用工厂方法管理对象生命周期，中层用状态机协调业务流程，上层用观察者实现事件广播。各模式不再是孤岛，而是在清晰的架构层级中协同工作，形成一致的设计语言。

2. **解耦的本质是降低跨模块变更的连锁反应**：重构前，修改一个 UI 组件可能要动数据模型，调整一个网络请求会影响本地缓存逻辑。我们通过引入接口抽象层，使高层模块只依赖抽象，不绑定具体实现。

3. **性能与可维护性并非对立，而是可协同优化的目标**：例如，在资源加载方面，通过对象池复用在角色使用工具、种植作物及收获作物的操作场景中，实现了多维度的优化提升，简化了调用方代码。这证明：良好的设计往往能同时带来性能和可读性的双重收益。

4. **工具链与工程规范是规模化重构的基石**：我们再github(https://github.com/Alian-yy/Stardew_Valley_Refactored)上进行项目管理,每一次提交都经过检查，每一次合并都伴随可视化差异对比。正是这些“看不见的基础设施”，支撑了我们在数百个文件中安全、高效地推进重构。

5. **技术决策应基于演进成本，而非短期便利**：用组合代替继承、用配置代替硬编码、用接口代替具体类。虽然初期多花 20% 时间，但后续每项新需求的开发速度提升 50% 以上。这让我们坚信：好的架构不是省时间，而是省未来的麻烦。

这次全栈式重构让我们意识到：优秀的软件不是一蹴而就的杰作，而是在持续反馈与迭代中不断自我修正的生命体。设计模式、架构原则、工程实践，只有融入团队日常开发习惯，才能真正转化为项目的长期竞争力。