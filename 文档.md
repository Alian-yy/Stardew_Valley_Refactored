# 星露谷项目文档

###### **目录：**

- [项目概述](#项目概述)
  - [项目背景](#项目背景)
  - [项目简介](#项目简介)
  - [项目主要功能](#项目主要功能)
- [使用设计模式重构](#使用设计模式重构)
  - [使用创建型模式重构](#使用创建型模式重构)
  - [使用结构型模式重构](#使用结构型模式重构)
  - [使用行为模式重构](#使用行为模式重构)
  - [使用课程未涉及的设计模式重构](#使用课程未涉及的设计模式重构)
- [项目展示](#项目展示)
- [总结](#总结)
  - [使用设计模式重构的意义](#使用设计模式重构的意义)
  - [本项目的重构方法](#本项目的重构方法)
  - [总结](#总结-1)
- [参考资料](#参考资料)

---

###### 项目名称：星露谷(2024年同济大学程序设计范式课程项目)

###### 团队编号：15 组

###### 团队成员：

| 姓名  | 学号      | 联系方式        | 电子邮件                  |
| --- | ------- | ----------- | --------------------- |
| 穆映雪 | 2351758 | 13163530936 | a05100936@163.com     |
| 于伊莲 | 2352993 | 18168165803 | 2352993@tongji.edu.cn |
| 张诗蔻 | 2353240 | 18980433878 | 2987991635@qq.com     |
| 王奕昕 | 2353733 | 18966812958 | 807576942@qq.com     |
| 林青滢 | 2354356 | 15259577899 | 2354356@tongji.edu.cn |

## 项目概述

### 项目背景

近年来，随着生活节奏加快与数字压力增加，越来越多玩家倾向于选择节奏舒缓、画面治愈的 “慢游戏” 来放松身心。以《星露谷物语》为代表的农场模拟类游戏，凭借其自由度高、玩法丰富、情感细腻的特点，成为独立游戏领域的现象级作品。这类游戏不仅融合了种植、养殖、建造、社交、探索等多种元素，还通过四季更替、昼夜循环和 NPC 日常行为等机制，构建出一个富有生命力的虚拟乡村世界，让玩家在耕耘与陪伴中获得成就感与情感共鸣。

在此背景下，项目通过实现一个具备完整农场生态、角色交互与场景切换功能的 2D 模拟游戏，将玩家置身于一个充满生机与温情的像素风乡村世界，在播种与收获中感受时间的流逝，在与村民的互动中体会人情的温暖，真正实现“逃离都市，回归田园”的游戏愿景。

### 项目简介

本项目是一款基于 Cocos2d-x 3.17.2 引擎开发的 2D 农场模拟游戏，灵感来源于经典独立游戏《星露谷物语》。游戏以像素风格呈现，玩家扮演一名来到乡村生活的主角，在一片待开垦的土地上开启全新的田园生活。

游戏包含多个可探索区域，支持场景无缝切换与角色位置记忆；NPC具备基本 AI 行为，可在限定范围内移动并与玩家触发对话；同时设计了背包系统、签到界面、钓鱼小游戏等辅助功能模块，提升游戏丰富度。在视听层面，项目集成了背景音乐、环境音效、UI 动画与天气效果，营造沉浸式的乡村氛围。

本项目在忠实还原经典农场模拟玩法的基础上，融入多项创新与增强功能，打造出兼具趣味性与沉浸感的乡村生活体验。主要特色包括：

- **沉浸式农场经营系统**：完整实现作物从播种、浇水、生长到收获的全周期管理，结合昼夜更替与天气变化，营造真实农耕节奏。  
- **可交互 NPC 与剧情触发**：村民与动物具备基础 AI 行为，玩家靠近时可触发对话，未来可扩展任务与好感度系统。  
- **多功能背包与物品管理**：设计多页签背包界面，支持物品拖拽、分类查看与使用操作，提升资源管理效率。  
- **多场景无缝切换**：通过场景状态管理器，实现农场、房屋、湖泊等区域间的平滑跳转，并自动保存与恢复玩家位置。  
- **丰富休闲玩法**：集成每日签到、钓鱼小游戏、动物互动等轻量级模块，增加日常游玩的多样性与乐趣。  
- **温馨视听体验**：搭配舒缓背景音乐、动态环境粒子及流畅 UI 动效，构建治愈系像素风世界。

这些特色共同构成了一个自由、温暖且富有生命力的虚拟田园，让玩家在耕耘与探索中感受慢生活的魅力。

### 项目主要功能
1. **菜单系统**：
* 游戏入口和导航，负责游戏的启动、导航和基本设置。它提供了一个友好的用户界面，让玩家能够轻松地访问游戏的各个功能模块。菜单系统包括主菜单、设置菜单、关于菜单等多个子菜单。
2. **农场场景**：
* 主要游戏区域，场景包含了一个完整的农场环境，含有地形、建筑、农作物、动物等各种游戏对象，支持多层地图和碰撞检测。
3. **角色系统**：
* 玩家可以通过控制角色来与游戏世界交互。角色系统包括角色属性、角色动作、角色状态等多个方面。角色会随着游戏的进行而升级。
4. **动物系统**：
* 动物系统管理农场上的各种动物，每个动物都有一些基本属性。
5. **种植系统**：
* 这个系统模拟了真实的农业过程，包括种植、生长、收获等阶段。农作物会随着游戏时间的推移而生长，玩家需要照料农作物以确保其正常生长。
6. **时间系统**：
* 游戏有自己的时间系统，与现实世界的时间不同。游戏时间流逝的速度可以配置，通常比现实时间快得多。时间系统包括分钟、小时、天、季节等多个时间单位。
7. **场景系统**：
* 游戏不是在一个单一的大场景中进行的，而是由多个不同的场景组成。每个场景都有自己的地图、对象、逻辑等。场景系统负责场景之间的切换、资源加载和卸载等。
8. **音频系统**：
* 音频系统提供了播放、暂停、停止、调整音量等功能。游戏中的不同场景和事件都有相应的音频，音频系统负责在适当的时机播放这些音频。游戏中各种事件和操作产生不同的音效。



## 使用设计模式的重构

### 使用行为模式重构

#### 使用策略模式 + 状态模式进行重构

#### 原有问题

1. **代码重复问题**：
* **DRY 原则违反**：相同的动画创建逻辑重复 3 次 。

* **维护困难**：动画参数分散在多个地方，修改一处需要改三处，容易遗漏且引入不一致性，最后需要大量的测试验证。

```cpp
bool Sheep::init(const std::string& filename){
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Sheep" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}

bool Cow::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Cow" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}

bool Parrot::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load animal image: %s", filename.c_str());
        return false;
    }

    animalmoveAnimation = Animation::create();
    for (int i = 1; i <= 4; i++) {
        std::string frameName = "animal/Parrot" + std::to_string(i) + ".png";
        animalmoveAnimation->addSpriteFrameWithFile(frameName);
    }
    animalmoveAnimation->setDelayPerUnit(0.1f); 
    animalmoveAnimation->setLoops(-1); 
    animalmoveAnimate = Animate::create(animalmoveAnimation);
    this->runAction(animalmoveAnimate);
    this->scheduleUpdate();
    return true;
}


```

2. **缺乏行为抽象**：系统中不同对象的行为没有被抽象成接口或基类，而是硬编码在具体的类中
- **行为固定，无法扩展**：所有动物都使用相同的移动逻辑，无法为不同对象定制不同的行为，无法实现不同的移动方式。
- **难以测试**：行为与数据紧耦合，行为直接访问和修改数据成员，无法独立测试行为和数据，也无法重用行为。


```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta * speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

3. **状态管理混乱**：
- **状态隐式**：原始代码中没有显式的状态管理，动物的行为完全由 update() 方法决定
- **行为难以理解**：没有获取状态的方法，无法清晰地了解当前对象所处的状态。状态与数据混淆在一起，无法清晰地区分。
- **无法转换**：原始代码中，动物只能处于一种隐式的状态：移动到目标。无法灵活地在不同状态间切换。

```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta * speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

4. **紧耦合设计**：
<p align="center">
  <img src="source/Coupled p.svg" alt="Presentation Layer" style="width:70%; max-width:700px; height:auto;"/>
</p>

* 羊，牛，鹦鹉子类的`init()`函数与`Sprite` , `Animation` ,` Animate`类耦合，一个模块的改变会直接影响其他模块，产生修改涟漪效应，导致代码难以维护和扩展。在测试方面，无法单独隔离测试子类，且测试速度慢，测试不稳定。

5. **难以添加新的功能**：
* 所有动物行为都在单一的 `update()` 方法中，包括的职责有：计算方向，更新位置，检查距离，生成新目标。这是一个"上帝方法"，做的事情太多，让阅读者难以理解。添加新的功能后，代码会迅速膨胀，且条件判断复杂，违反“开闭原则”。

```cpp
void Animal::update(float delta) {
    Vec2 direction = targetPosition - this->getPosition();
    this->setPosition(this->getPosition() + direction * delta *speed);

    if (this->getPosition().distance(targetPosition) < 10.0f) {
        generateNewTarget(); 
    }
}
```

6. **动画单一，视觉效果不佳**：
* 每个动物类型只有一种固定动画，暂时只有“默认行走”动画。无法体现不同行为的视觉差异，玩家将无法通过角色动作直观感知其行为意图——休息时仍在走动、追逐时速度无变化且动作无紧张感，严重削弱沉浸感与反馈清晰度，导致角色行为“表里不一”，降低游戏表现力与可信度。

#### 重构的必要性
* **业务需求驱动**：当前只有3 种动物（羊、牛、鹦鹉）， 1 种行为（游荡），1 种动画；而未来需要扩展更多种动物、行为种类（游荡、休息、追踪、觅食、逃跑）以及多种的动态动画切换。原始代码无法满足这些需求，重构后可以轻松扩展。
* **技术债务**：当代码重复率高达30-40%，代码中的决策点多，路径复杂，模块间耦合度高，容易有出错概率高，测试和维护难度越大。重构后可以降低维护成本，提高开发效率
* **开发效率**：原始代码添加新动物需要写 50+ 行重复代码，修改动画参数需要改 3 个地方，添加新行为需要修改 `update()` 方法，使得方法冗长。重构后添加新动物：只需写 10 行代码，修改动画参数只需改 1 个地方，添加新行为只需创建新状态类。效率提升效果明显。
* **游戏视觉**：原始代码的动物行为简单直接，适合开发初始阶段，可能美术资源未就位。重构后，在策略模式和行为模式的基础上，将动画与行为解耦，做到动物的动画展示随状态改变而改变，增强游戏的体验感和视觉享受。

#### UML类图
* 策略模式类图
<p align="center">
  <img src="source/Strategy.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>

<br></br>

* 状态模式类图
<p align="center">
  <img src="source/State.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>


#### 重构步骤
为解决上述问题，将运用策略模式和状态模式，将"所有动物共享一套固定的初始化和移动逻辑"重构为"每个动物可以选择自己的动画策略和运动状态"。让代码更好地服务于业务，以便之后更高效地开发和维护。

1. **明确重构目标**：
* **遵循单一职责原则**：`Animal` 只负责持有状态/策略，重构其他类专注行为逻辑和视觉表现。
* **遵循开闭原则**：使得新增动物类型，新增移动行为，更换动画风格更加容易。
* **解耦具体实现，依赖抽象**：底层图形引擎变化时，`Animal` 几乎不用改。
* **行为与动画解耦**：每个动物支持三种行为状态，同一动物可拥有多个策略，按需切换。
2. **建立动画策略体系**：
* 新建 `AnimationStrategy.h`
* 定义抽象接口 `AnimationStrategy`
```cpp
class AnimationStrategy {
public:
    virtual ~AnimationStrategy() = default;
    virtual void applyAnimation(Sprite* sprite) = 0;
};
```
* 实现通用策略类 `GenericAnimationStrategy`，支持按前缀加载帧序列
```cpp
class GenericAnimationStrategy : public AnimationStrategy {
private:
    std::string prefix;   
    int frameCount;
    float delay;

public:
    GenericAnimationStrategy(const std::string& animPrefix, int count = 4, float d = 0.1f)
        : prefix(animPrefix), frameCount(count), delay(d) {}

    void applyAnimation(Sprite* sprite) override {
        auto animation = Animation::create();
        bool hasValidFrame = false;
        for (int i = 1; i <= frameCount; ++i) {
            std::string frameName = prefix + std::to_string(i) + ".png";
            auto frame = SpriteFrameCache::getInstance()->getSpriteFrameByName(frameName);
            if (!frame) {
                auto texture = Director::getInstance()->getTextureCache()->addImage(frameName);
                if (texture) {
                    Rect rect = Rect::ZERO;
                    rect.size = texture->getContentSizeInPixels();
                    frame = SpriteFrame::createWithTexture(texture, rect);
                    hasValidFrame = true;
                }
            } else {
                hasValidFrame = true;
            }
            if (frame) {
                animation->addSpriteFrame(frame);
            }
        }

        if (!hasValidFrame) {
            CCLOG("Warning: No valid frames for animation prefix: %s", prefix.c_str());
            return;
        }

        animation->setDelayPerUnit(delay);
        animation->setLoops(-1); // loop forever
        auto animate = Animate::create(animation);
        sprite->stopAllActions();
        sprite->runAction(animate);
    }
};
```

3. **定义行为状态机**：
* 新建 `AnimalState.h`
* 声明抽象基类 `AnimalState`
```cpp
class AnimalState {
public:
    virtual ~AnimalState() = default;
    virtual void enter(Animal* animal) = 0;
    virtual void update(Animal* animal, float delta) = 0;
    virtual void exit(Animal* animal) = 0;
    virtual std::string getName() const = 0;
};
```
* 实现三种具体状态：
    * `WanderingState`：随机移动 + wander 动画
    * `ChasingState`：朝目标移动 + chase 动画（可设追逐点）
    * `RestingState`：静止 + rest 动画，3 秒后自动切回 wandering
```cpp
// ------------------ Wandering ------------------
class WanderingState : public AnimalState {
public:
    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            new GenericAnimationStrategy(animal->getAnimPrefix() + "_wander")
        );
        animal->generateNewTarget();
    }

    void update(Animal* animal, float delta) override {
        Vec2 dir = animal->getTargetPosition() - animal->getPosition();
        if (dir.length() < 10.0f) {
            animal->generateNewTarget();
        } else {
            animal->setPosition(animal->getPosition() + dir.getNormalized() * animal->getSpeed() * delta);
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Wandering"; }
};

// ------------------ Chasing ------------------
class ChasingState : public AnimalState {
private:
    Vec2 chaseTarget;
public:
    void setChaseTarget(const Vec2& target) { chaseTarget = target; }

    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            new GenericAnimationStrategy(animal->getAnimPrefix() + "_chase")
        );
    }

    void update(Animal* animal, float delta) override {
        Vec2 dir = chaseTarget - animal->getPosition();
        if (dir.length() > 5.0f) {
            animal->setPosition(animal->getPosition() + dir.getNormalized() * animal->getSpeed() * 1.8f * delta);
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Chasing"; }
};

// ------------------ Resting ------------------
class RestingState : public AnimalState {
private:
    float restTime = 0.0f;
    const float MAX_REST = 3.0f;

public:
    void enter(Animal* animal) override {
        animal->setAnimationStrategy(
            new GenericAnimationStrategy(animal->getAnimPrefix() + "_rest")
        );
        restTime = 0.0f;
    }

    void update(Animal* animal, float delta) override {
        restTime += delta;
        if (restTime >= MAX_REST) {
            animal->changeState(std::make_unique<WanderingState>());
        }
    }

    void exit(Animal* animal) override {}
    std::string getName() const override { return "Resting"; }
};

```

4. **改造 Animal 基类**：
* 在 `Animal.h` 中：
    * 添加成员：`unique_ptr<AnimalState> currentState` 和 `unique_ptr<AnimationStrategy> currentAnimation`
    * 添加方法：`changeState()`、`setAnimationStrategy()`
    * 声明虚函数 `getAnimPrefix()` 供子类指定资源前缀

```cpp
class Animal : public Sprite {
protected:
    Vec2 targetPosition; 
    Rect Bounds;
    float speed;
    std::string animPrefix;

    std::unique_ptr<AnimalState> currentState;
    std::unique_ptr<AnimationStrategy> currentAnimation;

public:
    Animal();
    virtual ~Animal();
    static Animal* create(const std::string& filename);
    virtual bool init(const std::string& filename) = 0;

    void generateNewTarget();
    void update(float delta);

    // State & Animation Control
    void changeState(std::unique_ptr<AnimalState> newState);
    void setAnimationStrategy(AnimationStrategy* strategy);

    // Getters
    Vec2 getTargetPosition() const { return targetPosition; }
    void setTargetPosition(const Vec2& pos) { targetPosition = pos; }
    float getSpeed() const { return speed; }
    const std::string& getAnimPrefix() const { return animPrefix; }
    const Rect& getBounds() const { return Bounds; }
};
```
* 在 Animal.cpp 中：
    * 实现 `update()` 转发给当前状态
    * 实现状态切换逻辑（调用 exit → enter）
    * 在 `setAnimationStrategy()` 中应用新动画并停止旧动作
```cpp
void Animal::update(float delta) {
    if (currentState) {
        currentState->update(this, delta);
    }
}

void Animal::changeState(std::unique_ptr<AnimalState> newState) {
    if (currentState) {
        currentState->exit(this);
    }
    currentState = std::move(newState);
    if (currentState) {
        currentState->enter(this);
    }
}

void Animal::setAnimationStrategy(AnimationStrategy* strategy) {
    currentAnimation.reset(strategy);
    if (strategy && this->isRunning()) {
        strategy->applyAnimation(this);
    }
}
```

5. **更新具体动物类**
* 修改 `Sheep`、`Cow`、`Parrot` 的构造函数：
    * 设置各自的 `animPrefix`
    * 初始化时调用 `changeState(std::make_unique<WanderingState>())`
* 移除原有硬编码动画逻辑

```cpp
bool Sheep::init(const std::string& filename){
   if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Sheep image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Sheep";
    changeState(std::make_unique<WanderingState>());
    this->scheduleUpdate();
    return true;
}

```
```cpp
bool Cow::init(const std::string& filename) {
    if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Cow image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Cow";
    changeState(std::make_unique<WanderingState>());
    this->scheduleUpdate();
    return true;
}
```

```cpp
bool Parrot::init(const std::string& filename) {
     if (!Sprite::initWithFile(filename)) {
        CCLOG("Error: Failed to load Parrot image: %s", filename.c_str());
        return false;
    }
    animPrefix = "animal/Parrot";
    changeState(std::make_unique<WanderingState>());
    this->scheduleUpdate();
    return true;
}
```

#### 改进与收益
1. **降低代码重复率**：
* 原来每个子类都要自己创建动画，但创建逻辑完全相同。子类继承了基类的所有代码，但无法复用基类的逻辑，只能重复实现。用抽象层进行集中管理后，可以避免在许多地方重复编写相同的代码
2. **降低耦合度**：
* 重构后 `Animal` 耦合 `AnimationStrategy` 和 `AnimalState` ，与 `Sprite` 、`Animation` 、`Animate` 松耦合。Animal 只负责“动物”的高层逻辑，动画和移动细节交给策略/状态，符合单一职责原则。
3. **增强扩展性**：
* 添加新的动物行为状态，只需要在 `AnimalState.h` 中新增状态类。代码可以在运行时改变动画策略和状态。
4. **提高代码的可读性**：
* 将策略和状态独立成类，使得代码结构更加清晰，意图明确，需要注释的地方减少。
5. **“状态”真正驱动“表现”**:
* 动画策略与“状态”对齐，而非与“动物类型”绑定。每个动物支持三种行为状态，同一动物可拥有多个策略，按需切换。状态切换时自动切换对应动画，动画资源与行为状态一一对应，清晰明确使用带参数的通用策略，而非为每种组合创建新类，可以防止类的爆炸

## 使用课程未涉及的设计模式重构

### 使用对象池模式重构

#### 模式解释  
**对象池模式**是一种创建型设计模式，它通过**预先创建并复用一组初始化好的对象**，避免在运行时频繁地创建和销毁对象。当客户端需要对象时，从池中“借出”；使用完毕后，将对象“归还”到池中，而不是直接销毁。该模式特别适用于**创建成本高、使用频繁、生命周期短**的对象管理。

#### 核心思想  
- **复用优于重建**：对象不是用完就丢，而是回收再利用。  
- **资源预分配**：在系统空闲或启动时预先创建一批对象，减少运行时开销。  
- **控制资源总量**：通过池大小限制并发对象数量，防止内存爆炸。

#### 工作流程  
1. **初始化池**：创建一批对象，放入“空闲队列”。
2. **获取对象**：
   - 若空闲队列非空 → 取出一个对象，重置其状态（如位置、属性），返回给客户端。
   - 若队列为空 → 可选择：
     - 阻塞等待；
     - 动态创建新对象（可选）；
     - 抛出异常（严格池）。
3. **归还对象**：客户端调用 `release()`，对象被放回空闲队列（不清除内存）。
4. **销毁池**：程序结束时统一释放所有对象。

#### 优点  
* **提升性能** ：避免频繁 `new/delete` 或 `malloc/free` 的开销（尤其对复杂对象）。
* **减少内存碎片** ：对象地址相对固定，降低堆内存碎片化。 
* **控制资源使用** ：限制最大对象数，防止系统过载（如数据库连接池）。 
* **降低 GC 压力**：减少临时对象生成，减轻垃圾回收负担 。
* **提高响应速度**： 获取对象是 O(1) 操作，无初始化延迟 。

#### 缺点  
* **内存占用增加**：对象常驻内存，即使未使用也占用空间。
* **状态管理复杂**：归还对象必须彻底重置状态，否则会污染下一次使用。
* **线程安全问题**：多线程环境下需加锁，可能成为性能瓶颈。
* **不适合长生命周期对象**：若对象长期被占用，池的优势无法体现。
* **调试困难**：对象复用可能导致难以追踪的逻辑错误（如残留数据）。

#### 应用场景  
* **游戏开发**：子弹、粒子、敌人、动画对象（频繁创建/销毁）。
* **Web 后端**：数据库连接池（如 HikariCP）、HTTP 客户端池。
* **网络编程**：Socket 连接、缓冲区（Buffer）复用。
* **科学计算**：矩阵、向量等大型数据结构缓存。
* **移动端**：RecyclerView / ListView 的 ViewHolder 复用（Android）。
* **AI/仿真系统**：传感器数据包、事件对象池。

---

#### 原有问题
1. **资源耗尽风险**
- 每次请求或任务都创建新线程，线程数量可能无限制增长。
- 大量线程会耗尽内存，导致 `OutOfMemoryError`。

2. **性能开销大**
- 线程创建/销毁成本高，涉及内核调度、内存分配、上下文切换等。
- 频繁创建线程会导致 CPU 大量时间花在调度而非业务逻辑上。
- 响应延迟增加，吞吐量下降。

3. **缺乏控制与管理**
- 无法限制最大并发数，容易引发雪崩效应。
- 无法监控活跃线程数、任务队列状态。
- 无法优雅关闭、等待任务完成、拒绝过载任务等。

4. **缺乏高级功能支持**
- 无法实现定时任务、周期任务（需配合 `Timer` 或手动实现）。
- 不支持任务返回结果（`Future`）、超时控制、批量提交等。

#### 重构的必要性

#### UML类图
* 对象池类图
<p align="center">
  <img src="source/.svg" alt="Presentation Layer" style="width:100%; max-width:1200px; height:auto;"/>
</p>



#### 重构步骤



#### 改进与收益

